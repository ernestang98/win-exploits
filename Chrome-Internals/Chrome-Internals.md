# JavaScript Overview

How does javascript work?

```
code -> token -> ast -> bytecode -> optimized code
``` 

- V8 handles parsing code into AST

- Ignition handles interpreting AST into Bytecode

- Sparkplug compiles Bytecode into non-optimized native code

- [NEW] Maglev is a mid-tier optimizer which optimizes non-optimized native code to semi-optimized maglev nativ code

- Turbofan optimised non-optimized native code

Some interesting stuff:

- [Understanding V8's Bytecode](https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775)

- [V8 Binding Design](https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/bindings/core/v8/V8BindingDesign.md)

- [V8 Inline Caching](https://javascript.plainenglish.io/v8-engine-and-inline-caching-in-javascript-fef80054a551)

# V8 Object Internals

Javascript types are dynamic, but how does this shit work if javascript is based on c++ which is statically typed? - Map a.k.a. Hidden Class (Shape)

Most objects are structured as so:

```
--------------
|     Map    |
--------------
| Properties |
--------------
|  Elements  |
--------------
```

Properties points to the values in the key-value pairs of object while Elements points to the values in an array/in an object (numbered properties) (both technically can function as backing stores). There are 2 kinds of properties:

1. Fast Properties

2. Slow/Dictionary Properties

# Pointer Tagging

- In v8, values represented as objects and allocated on the heap

- If we need to keep allocating on heap everytime we manipulate/create/delete object, that sucks

- Instead, store some of the values inline so that we dont have to keep using the heap

- Then how to differentiate object pointer from inline value? Pointer Tagging

# Pointer Compression

- Use 4 bytes instead of 8 bytes 

- MSB stored in r13

- Serve as some form of sandbox 

# Chrome Architecture

- V8: JavaScript Engine

- Blink: Renderer Engine

- Mojo: IPC between Browser and Renderer

- Renderer Sandbox: 1 tab = 1 renderer = 1 process (low privileges)

- Isolate: a running instance of a V8 engine (like a thread to a process?). 1 thread is allocated 1 isolate object

- Context: global scope for variables, allows differentiating of variables belonging to 1 window from another

- [Chromium heap allocators](https://chromium.googlesource.com/chromium/src/base/+/master/allocator/)

# Blink

- Renderer Engine, forked from WebKit

- [Uses various allocators](https://chromium.googlesource.com/chromium/src/+/0e94f26e8/third_party/WebKit/Source/wtf/Allocator.md)

# Debugging Things

```
d8.exe --allow-natives-syntax --trace-opt
bp v8!v8::internal::Runtime_DebugPrint
"C:\Users\kali\AppData\Local\Google\Chrome\Application\chrome.exe" --no-sandbox --js-flags="--allow-natives-syntax" --enable-logging --v=1
"C:\Program Files\Google\Chrome\Application\chrome.exe" --no-sandbox --js-flags="--allow-natives-syntax" --enable-logging --v=1
```

- There are other hacky ways of debugging Chrome/V8. Take some inspiration from [this](https://www.cnblogs.com/Ox9A82/p/5777235.html) old but gold technique used in IE

# Utilities

[hex to float #1](https://resource.heltec.cn/utils/hf)

[hex to float #2](https://gregstoll.com/~gregstoll/floattohex/)

[gdb macro job](https://stackoverflow.com/questions/58433681/i-want-to-use-job-command-in-v8-release-so-how-can-i-do-it-or-just-by-pass-th)

# Blink

[Memory management in Blink](https://chromium.googlesource.com/chromium/src/third_party/WebKit/Source/wtf/+/06465eaa2f65e6a1f550615ce17c209c7da95ffb/Allocator.md)
