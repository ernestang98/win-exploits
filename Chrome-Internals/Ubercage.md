# Ubercage

### Sandboxifying Backing Stores

- Backing Stores are used to create Arbitrary R/W and RCE primitives, and historically stored as 64bit pointers and are easily read using compressed read/write primitives

- One feature of Ubercage sandboxifies the backing stores - instead of storing the actual pointer itself, we store indices which can be resolved to the respective backing store

- In order to bypass this and still create RCE without arbitrary R/W primitives, we can use JIT Spraying/Shellcoding

### External Pointer Table (July 2022)

ag GetExternalPointer

```
  V8_INLINE static Address ReadExternalPointerField(v8::Isolate* isolate,
                                                    Address heap_object_ptr,
                                                    int offset) {
#ifdef V8_ENABLE_SANDBOX
    static_assert(tag != kExternalPointerNullTag);
    // See src/sandbox/external-pointer-table-inl.h. Logic duplicated here so
    // it can be inlined and doesn't require an additional call.
    Address* table = IsSharedExternalPointerType(tag)
                         ? GetSharedExternalPointerTableBase(isolate)
                         : GetExternalPointerTableBase(isolate);
    internal::ExternalPointerHandle handle =
        ReadRawField<ExternalPointerHandle>(heap_object_ptr, offset);
    uint32_t index = handle >> kExternalPointerIndexShift;
    std::atomic<Address>* ptr =
        reinterpret_cast<std::atomic<Address>*>(&table[index]);
    Address entry = std::atomic_load_explicit(ptr, std::memory_order_relaxed);
    return entry & ~tag;
#else
    return ReadRawField<Address>(heap_object_ptr, offset);
#endif  // V8_ENABLE_SANDBOX
  }
```

```
V8_INLINE static Address* GetExternalPointerTableBase(v8::Isolate* isolate) {
    Address addr = reinterpret_cast<Address>(isolate) +
                    kIsolateExternalPointerTableOffset +
                    kExternalPointerTableBasePointerOffset;
    return *reinterpret_cast<Address**>(addr);
}
```

### Code Pointer Table (December 2022/July 2023)

- Sandboxifies code pointers to native code created by JITed functions, as per [documentation](https://docs.google.com/document/d/1CPs5PutbnmI-c5g7e_Td9CNGh5BvpLleKCqUnqmD82k/edit#heading=h.xzptrog8pyxf)

- CPT was introduced into V8 and hence Chrome source code on [Jul 6, 2023](https://groups.google.com/g/v8-reviews/c/bLrgEfZNGZ4) which should indicate that the CPT was introduced in Chrome 115 and the last version without CPT should be in Chrome 114. However, the JIT spray technique seems to be viable till Chrome 116, so the CPT was fully functioning from Chrome 117 onwards?

    ![](./screenshots/ubercage_cpt/before_cpt_commit.png)

    ![](./screenshots/ubercage_cpt/chrome_116.0.5845.42_v8_no_cpt.png)

    ![](./screenshots/ubercage_cpt/chrome_117.0.5897.3_cpt.png)

- On Windows, this doesnt rly matter cause we can continue abusing the shit out of WASM on windows from Chrome 110 (till Chrome 122 when they sandboxified the raw pointer to the RWX space via WasmTrustedInstanceData)

- If we are still interested in executing JIT spray, I think it is still possible? All we need to do is to figure out where the handle is located and the algorithm used to convert the handle to an index, as well as the algorithm to calculate the address to the CPT

    1. Algorithm to calculate address to CPT: CPTBaseAddress = ExternalEntityTable[Index]

    2. Algorithm to calculate index of CPT to JSFunc: CPTIndex = handle >> kCodePointerIndexShift

    3. Final Address: CPTBaseAddress+CPTIndex

### Trusted Pointer Table (October 2023/December 2023)

- Sandboxifies pointers to Heap Objects located outside the V8 Heap found in V8 objects, as per [documentation](https://docs.google.com/document/d/1IrvzL4uX_Zv0k2Iakdp_q_z33bj-qlYF5IesGpXW0fM/edit).

- On [Dec 5, 2023](https://groups.google.com/g/v8-reviews/c/lQc9yuGq0iI), chrome sandboxified raw pointers to RWX space from WASM Instances by putting the WASM Instances into trusted space, implemented from Chrome 122 and onwards

- This is a very big issue as we can no longer abuse WASM spaces to obtain RCE

- In order to bypass this, we will need to figure out how the handles are converted to the actual raw pointers in the TPT

    1. Algorithm to calculate address to TPT: TPTBaseAddress = Isolate+OffsetToTPT

    2. Algorithm to calculate index of TPT: TPTIndex = (handle >> kTrustedPointerIndexShift) * TrustedPointerEntrySpace

# Ubercage Escapes

### JIT Spraying/Shellcoding

- This technique bypasses W^X protection on JIT Functions and WASM spaces.

- It is stable on x86_64 based OSes (Windows and some families of Linux) until CPT was introduced, where the code pointers are replaced by indices and only accessible via the code pointer table.

- In CVE-2018-17463, we briefly went through the possibility of bypassing W^X protection on JIT-ed functions but did not dive into it due to the fact that we could get away with abusing WASM spaces

- The introduction of W^X protection on WASM spaces (from Chrome 100 and onwards up till before Chrome 110 for Windows) did not deter us from continue using WASM to RCE due to the fact that we could still create arbitrary r/w primitives by bitmap flipping the appropriate locations in chrome in order to disable the protection ([wasm_write_protect_code_memory](https://medium.com/deno-the-complete-reference/v8-flags-supported-by-deno-f5f7a946dadb)). Verified the versions manually... 

- I'm guessing the reason why WASM was set back to RWX from chrome 110 onwards was due to maybe the belief that because of Ubercage and the sandboxifying of arraybuffer backing stores, they wouldn't need to implement the W^X protection on WASM spaces and hence removed it to improve efficiency (an interpreted waste of setting the WASM space from RW- to R-X and vice versa)

- In Chrome 103, arraybuffer backingstores were sandboxed and in order to access the backingstore, you would need to find the base location of the v8 sandbox and add it with index*0x100 (as per the [documentation](https://docs.google.com/document/d/1FM4fQmIhEqPG8uGp5o9A-mnPB5BOeScZYpkHjo0KKA8/edit), this base location is found in r14). Given that in a typical chrome bug, it is unlikely for us to leak this value, we need to be creative in obtaining our RCE.

    ![](./screenshots/ubercage_sandboxify_backingstores/Chrome_104.0.5112.81_ArrayBuffer_BackingStore-1.png)

    ![](./screenshots/ubercage_sandboxify_backingstores/Chrome_104.0.5112.81_ArrayBuffer_BackingStore-2.png)

- Looking at how JIT-ed functions work when returning floats, we observe that we can smuggle shellcode inside floats as seen in CVE-2018-17463, we need to note that:

    1. The maximum length of each instruction needs to be lesser or equal to 6 bytes (cause we also need to jump to our next float)

    2. In Windows, where we need to craft Position Independent shellcode, jumping and calling is a pain but still possible

    3. We need to make sure that each float is unique if not V8 will optimise the way the floats are passed around (instead of generating the 8 byte integer, it will simply play around with the float registers with the duplicate values)

- `jit_spraying.py` is a script which will generate the appropriate Uint8Array which we can later convert to a float array

- Here, we are able to bypass the W^X protections implemented without needing any arbitrary r/w primitives

### Todo

- CVE-2023-2033 Chrome 110/109 if can

- CVE-2023-4096 Chrome 115

- CVE-2024-0517 Chrome 120

- EPT Experiments

- Build DiceCTF