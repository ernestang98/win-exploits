# Current state of V8 Exploitation

### Objective:

```
Bug -> Primatives -> RWX -> RCE 
```

- If you have arb r/w and you can leak the location of RWX, you can slowly write in your shellcode 4/8 bytes by 4/8 bytes

- On earlier versions of Chrome, where we could r/w the backing store of ArrayBuffers, we can simply change it to the location of the RWX space and abuse the native JavaScript functions such as `.set()` to quickly write in our shellcode

### RCE:

Prior to "Early 2018" (as per [phrack](http://www.phrack.org/issues/70/9.html))

- JIT functions are RWX

- We can JIT a function to create RWX space, before using our primatives to write shellcode and obtain RCE (ezpz)

- [Mitigation: R-X/RW-X](https://github.com/v8/v8/commit/14917b6531596d33590edb109ec14f6ca9b95536) (a.k.a [W^X](https://en.wikipedia.org/wiki/W%5EX))

    > Bypass #1: Bitmap flip FLAG_write_protect_code_memory - need Arbitrary R/W, [see](https://tiszka.com/blog/CVE_2021_21225_exploit.html)

Prior to TPT (Ubercage)

- Abuse WASM spaces which are RWX

- [Mitigation: kWebAssemblyCodeProtectionPku (Protects RWX WASM from being written)](https://starlabs.sg/blog/2022/12-the-hole-new-world-how-a-small-leak-will-sink-a-great-browser-cve-2021-38003/)

    > Bypass #1: Bitmap flip FLAG_write_protect_code_memory via OfflineAudioContext (set to 0) - need Arbitrary R/W, [see](https://tiszka.com/blog/CVE_2021_21225_exploit.html)

Prior to CPT (Ubercage)

- JIT "Shellcoding"?

- Even though JIT code are R-X, we can spray an array of functions such as `const jit = () => { return [1.1, 2.2, 3.3, 4.4] }`

- Each float is 64 bits and we can "hide" shellcode in the floats before "jumping" from float to float in order to get a full RCE

### Obtaining Arbitrary R/W

Prior to Chrome 80 as per [gpz](https://googleprojectzero.blogspot.com/2021/01/in-wild-series-chrome-exploits.html)

- Pointer Compression NOT used

- No V8 "sandbox" (pointer compression is not really a proper sandbox but it does ensure that if you write a backing store in a form of a compressed pointer such as the element or property pointers, your primatives can only work in the V8 heap space)

- We can easily obtain arbitrary r/w (ezpz)

Prior to ArrayBuffer sandboxing (Ubercage)

- In order to obtain arbitrary r/w, we need to be able to control raw pointers. A commonly abused raw pointer is backing stores in ArrayBuffer objects

- We can escalate sandboxed/compressed r/w into arbitrary r/w by reading and writing 64 bits into the compressed heap space of V8. If we have an OOB object, we can possibly abuse it to write to raw pointers as well (just like how we can write compressed pointers)

# Ubercage

monitor here https://source.chromium.org/chromium/chromium/src/+/main:v8/src/sandbox/README.md

### Sandboxifying Backing Stores

- Backing Stores are used to create Arbitrary R/W and RCE primitives, and historically stored as 64bit pointers and are easily read using compressed read/write primitives

- If we can control the backing store, we can construct arbitrary R/W primitives via compressed R/W

- If we can control the backing store, we can store shellcode and create RCE

- One feature of Ubercage sandboxifies the backing stores - instead of storing the actual pointer itself, we store indices which can be resolved to the respective backing store

- This feature seems to be implemented from Chrome 103 and onwards for Windows platforms

    ![](./screenshots/ubercage_sandboxify_backingstores//Chrome_102.0.5005.63_ArrayBuffer_BackingStore.png)
    *Chrome 102.0.5005.63 (Last apprent version of Chrome before ArrayBuffer Backing Store were sandboxed)*

    ![](./screenshots/ubercage_sandboxify_backingstores//Chrome_104.0.5112.81_ArrayBuffer_BackingStore-2.png)
    *Chrome 104.0.5112.81*

- In order to bypass this and still create RCE without arbitrary R/W primitives, we can use JIT Spraying/Shellcoding

### External Pointer Table (July 2022)

- Sandboxifies raw pointers to blink objects stored in its V8 counter parts, as per [documentation](https://docs.google.com/document/d/1V3sxltuFjjhp_6grGHgfqZNK57qfzGzme0QTk0IXDHk/edit#heading=h.xzptrog8pyxf)

- EPT was introduced in Chrome 107 on Windows

- In order to still obtain the blink address of blink objects, we would need to understand how v8 calculates it. We can search for `*GetExternalPointer*` in Chromium source code and obtain the following results:

    ```
    V8_INLINE static Address ReadExternalPointerField(v8::Isolate* isolate,
                                                        Address heap_object_ptr,
                                                        int offset) {
    #ifdef V8_ENABLE_SANDBOX
        static_assert(tag != kExternalPointerNullTag);
        // See src/sandbox/external-pointer-table-inl.h. Logic duplicated here so
        // it can be inlined and doesn't require an additional call.
        Address* table = IsSharedExternalPointerType(tag)
                            ? GetSharedExternalPointerTableBase(isolate)
                            : GetExternalPointerTableBase(isolate);
        internal::ExternalPointerHandle handle =
            ReadRawField<ExternalPointerHandle>(heap_object_ptr, offset);
        uint32_t index = handle >> kExternalPointerIndexShift;
        std::atomic<Address>* ptr =
            reinterpret_cast<std::atomic<Address>*>(&table[index]);
        Address entry = std::atomic_load_explicit(ptr, std::memory_order_relaxed);
        return entry & ~tag;
    #else
        return ReadRawField<Address>(heap_object_ptr, offset);
    #endif  // V8_ENABLE_SANDBOX
    }
    ...
    V8_INLINE static Address* GetExternalPointerTableBase(v8::Isolate* isolate) {
        Address addr = reinterpret_cast<Address>(isolate) +
                        kIsolateExternalPointerTableOffset +
                        kExternalPointerTableBasePointerOffset;
        return *reinterpret_cast<Address**>(addr);
    }
    ```

- The calculations are as follows:

    1. Algorithm to calculate address to TPT: TPTBaseAddress = Isolate+OffsetToTPT

    2. Algorithm to calculate index of TPT to JSFunc: TPTIndex = (handle >> kExternalPointerIndexShift) * ExternalPointerEntrySpace

    3. Final Address: EPTBaseAddress+EPTIndex

### Code Pointer Table (December 2022/July 2023)

- Sandboxifies code pointers to native code created by JITed functions, as per [documentation](https://docs.google.com/document/d/1CPs5PutbnmI-c5g7e_Td9CNGh5BvpLleKCqUnqmD82k/edit#heading=h.xzptrog8pyxf)

- CPT was introduced into V8 and hence Chrome source code on [Jul 6, 2023](https://groups.google.com/g/v8-reviews/c/bLrgEfZNGZ4) which should indicate that the CPT was introduced in Chrome 115 and the last version without CPT should be in Chrome 114. However, the JIT spray technique seems to be viable till Chrome 116, so the CPT was fully functioning from Chrome 117 onwards?

    - Chrome release dashboard (windows)

        ![](./screenshots/ubercage_cpt/before_cpt_commit.png)

    - Chrome 116 (with no CPT)

        ![](./screenshots/ubercage_cpt/chrome_116.0.5845.42_v8_no_cpt.png)

    - Chrome 117 (with CPT) - realise that the pointer no native code is no longer found here

        ![](./screenshots/ubercage_cpt/chrome_117.0.5897.3_cpt.png)

- On Windows, this doesnt rly matter cause we can continue abusing the shit out of WASM on windows from Chrome 110 (till Chrome 122 when they sandboxified the raw pointer to the RWX space via WasmTrustedInstanceData)

- If we are still interested in executing JIT spray, I think it is still possible? All we need to do is to figure out where the handle is located and the algorithm used to convert the handle to an index, as well as the algorithm to calculate the address to the CPT

    1. Algorithm to calculate address to CPT: CPTBaseAddress = ExternalEntityTable[CodePointerTableEntryIndex]

        ![](./screenshots/ubercage_cpt/chrome_117.0.5897.3_v8_retrieval_of_external_entity_table_base.png)

    2. Algorithm to calculate index of CPT to JSFunc: CPTIndex = (handle >> kCodePointerIndexShift) * CodePointerEntrySpace

        ![](./screenshots/ubercage_cpt/chrome_117.0.5897.3_v8_retrieval_of_external_entity_table_base.png)

        - Each CodePointerEntrySpace is 16 bytes as seen in the previous screenshot, hence we do a shl 4 because shl 4 is equivalent to x16

    3. Final Address: CPTBaseAddress+CPTIndex

        ![](./screenshots/ubercage_cpt/chrome_117.0.5897.3_v8_retrieval_of_actual_address.png)

### Trusted Pointer Table (October 2023/December 2023)

- Sandboxifies pointers to Heap Objects located outside the V8 Heap found in V8 objects, as per [documentation](https://docs.google.com/document/d/1IrvzL4uX_Zv0k2Iakdp_q_z33bj-qlYF5IesGpXW0fM/edit).

- On [Dec 5, 2023](https://groups.google.com/g/v8-reviews/c/lQc9yuGq0iI), chrome sandboxified raw pointers to RWX space from WASM Instances by putting the WASM Instances into trusted space, implemented from Chrome 122 and onwards

- This is a very big issue as we can no longer abuse WASM spaces to obtain RCE

- In order to bypass this, we will need to figure out how the handles are converted to the actual raw pointers in the TPT

    1. Algorithm to calculate address to TPT: TPTBaseAddress = Isolate+OffsetToTPT

        ![](./screenshots/ubercage_tpt/chrome_122.0.6261.57_tpt.png)

    2. Algorithm to calculate index of TPT: TPTIndex = (handle >> kTrustedPointerIndexShift) * TrustedPointerEntrySpace

        ![](./screenshots/ubercage_tpt/chrome_122.0.6261.57_handle_to_tpt_entry.png)

    3. Final Address: TPTBaseAddress+TPTIndex

### External Buffer Table

https://groups.google.com/g/v8-reviews/c/fgJFek3SR4Q

### Cpp Heap Pointer Table

https://groups.google.com/a/chromium.org/g/oilpan-reviews/c/ubYUcgNJeT0

# Ubercage SBX

### Leaking Cage Base

- Base address of the cage can be easily leaked using the sandboxed read/write primitives. Since we can technically set the compressed pointer value from 0x0 to 0xFFFFFFFF, we can read the starting few values of the V8 heap base which should have some references, this technique was used in Dice CTF 2022 Memory Hole

    ![](../Chrome-CTF/dicectf2022._challenge/screenshots/search_for_js_heap_base.png)

- We can create "extended" sandboxed primitives which can read "slightly" out of the V8 heap space using TypedArrays. By manipulating the external pointer and the base pointer values, we can read up to 0xFFFFFFFF00+0xFFFFFFFF from the V8 heap base. This technique was used in Dice CTF 2022 Memory Hole

    ![](../Chrome-CTF/anvbis.au_challenge/screenshots/typedarray_rw_primitives.png)

- We can also stuff our shellcode in a TypedArray, manually calculate the full pointer to its backing store (only requiring sandboxed primitives), before copying the shellcode over to our RWX space (requiring arbitrary write primitives).

### JIT Spraying/Shellcoding

- This technique bypasses W^X protection on JIT Functions and WASM spaces (because we can RCE without WASM).

- It is stable on x86_64 based OSes (Windows and some families of Linux) until CPT was introduced, where the code pointers are replaced by indices and only accessible via the code pointer table.

- In CVE-2018-17463, we briefly went through the possibility of bypassing W^X protection on JIT-ed functions but did not dive into it due to the fact that we could get away with abusing WASM spaces

- The introduction of W^X protection on WASM spaces (from Chrome 100 and onwards up till before Chrome 110 for Windows) did not deter us from continue using WASM to RCE due to the fact that we could still create arbitrary r/w primitives by bitmap flipping the appropriate locations in chrome in order to disable the protection ([wasm_write_protect_code_memory](https://medium.com/deno-the-complete-reference/v8-flags-supported-by-deno-f5f7a946dadb)). Verified the versions manually... 

- I'm guessing the reason why WASM was set back to RWX from chrome 110 onwards was due to maybe the belief that because of Ubercage and the sandboxifying of arraybuffer backing stores, they wouldn't need to implement the W^X protection on WASM spaces and hence removed it to improve efficiency (an interpreted waste of setting the WASM space from RW- to R-X and vice versa)

- In Chrome 103, arraybuffer backingstores were sandboxed and in order to access the backingstore, you would need to find the base location of the v8 sandbox and add it with index*0x100 (as per the [documentation](https://docs.google.com/document/d/1FM4fQmIhEqPG8uGp5o9A-mnPB5BOeScZYpkHjo0KKA8/edit), this base location is found in r14). Given that in a typical chrome bug, it is unlikely for us to leak this value, we need to be creative in obtaining our RCE.

    ![](./screenshots/ubercage_sandboxify_backingstores/Chrome_104.0.5112.81_ArrayBuffer_BackingStore-1.png)

    ![](./screenshots/ubercage_sandboxify_backingstores/Chrome_104.0.5112.81_ArrayBuffer_BackingStore-2.png)

- Looking at how JIT-ed functions work when returning floats, we observe that we can smuggle shellcode inside floats as seen in CVE-2018-17463, we need to note that:

    1. The maximum length of each instruction needs to be lesser or equal to 6 bytes (cause we also need to jump to our next float)

    2. In Windows, where we need to craft Position Independent shellcode, jumping and calling is a pain but still possible

    3. We need to make sure that each float is unique if not V8 will optimise the way the floats are passed around (instead of generating the 8 byte integer, it will simply play around with the float registers with the duplicate values)

- `jit_spraying.py` is a script which will generate the appropriate Uint8Array which we can later convert to a float array

- Here, we are able to bypass the W^X protections implemented without needing any arbitrary r/w primitives

### imported_mutable_globals

- This technique allows us to obtain arbitrary write primitive primitives, patched on [August 29, 2022](https://chromium-review.googlesource.com/c/v8/v8/+/3845636)

- imported_mutable_globals is created when our WASM instance has a WASM Global object. This WASM Global object is in the V8 space and can be referenced via the WASMInstance object as a half-pointer. The half-pointer points to a full pointer which points another full pointer (actual location of the Global Object) which points to the actual value of the Global Object.

    ```
    var global = new WebAssembly.Global({value:'i64', mutable:true}, 0n); 
    ...
    var wasm_instance = new WebAssembly.Instance(wasm_mod, {js: {global}});
    ```

    ```
    (module
        ;; need to make sure this matches with what you are importing and how you are importing it
        (global $g (import "js" "global") (mut i64)) 
        (func (export "getGlobal") (result i64)
                (global.get $g))
        (func (export "incGlobal")
                (global.set $g
                    (i64.add (global.get $g) (i64.const 1))))
        (func (export "setGlobal") (param $p1 i64)
                (global.set $g (local.get $p1)))
    )
    ```

    ```
    wasm_instance -> imported_global_mutables -> full_pointer_to_js_global -> value
    ```

- The reason why its a full pointer to another full pointer is because I am guessing that you can import more than 1 global WASM object

- Anyway, since we can control the imported_global_mutables pointer, we can set it to a pointer which points to the address we want to arbitrarily read/write to/from

- You can reference my attempt at the DiceCTF 2022 Memory Hole challenge to see the full exploitation method to abuse this technique to get RCE (note that there is no W^X on WASM and there is no TPT for this challenge, but even if there was, I do not think it will be an issue since we have arbitrary r/w primitives)


[Liftoff](https://retr0.zip/blog/abusing-Liftoff-assembly-and-efficiently-escaping-from-sbx.html)

[Shellcode Spraying via WAT](https://github.com/candymate/csed499I-01/blob/master/README.md)

[Shellcode Spraying via JIT](https://anvbis.au/posts/code-execution-in-chromiums-v8-heap-sandbox/)

[imported_function_targets](https://blog.theori.io/a-deep-dive-into-v8-sandbox-escape-technique-used-in-in-the-wild-exploit-d5dcf30681d4)

[tiering_budget_array](https://issues.chromium.org/issues/40068627)

https://retr0.zip/blog/abusing-Liftoff-assembly-and-efficiently-escaping-from-sbx.html

https://medium.com/@numencyberlabs/use-wasm-to-bypass-latest-chrome-v8sbx-again-639c4c05b157

https://medium.com/@numencyberlabs/use-native-pointer-of-function-to-bypass-the-latest-chrome-v8-sandbox-exp-of-issue1378239-251d9c5b0d14

- CVE-2023-2033 Chrome 110/109 if can

- CVE-2023-4096 Chrome 115

- CVE-2024-0517 Chrome 120

- https://securitylab.github.com/research/CVE-2020-6449-exploit-chrome-uaf/

- https://blog.exodusintel.com/2019/03/20/cve-2019-5786-analysis-and-exploitation/ (maybe dont need if similar enough)

- https://blog.perfect.blue/Chromium-Fullchain

- https://www.exploit-db.com/exploits/50917

- https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_1/

- https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_2/

for fun https://www.zerodayinitiative.com/blog/2020/9/2/cve-2020-9715-exploiting-a-use-after-free-in-adobe-reader

for fun https://www.zerodayinitiative.com/blog/2021/2/17/zdi-21-171-getting-information-disclosure-in-adobe-reader-through-the-id-tag

### Current state of Chrome Exploitation (V8 UaF)

CVE-2019-5786

- https://blog.exodusintel.com/2019/03/20/cve-2019-5786-analysis-and-exploitation/

WebAudio CVE-2020-6449 

- https://www.anquanke.com/post/id/221043

- https://packetstormsecurity.com/files/172843/Chrome-WebAudio-Use-After-Free.html

- https://securitylab.github.com/research/CVE-2020-6449-exploit-chrome-uaf/ 

CVE-2021-37975

- https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2021/CVE-2021-37975.html

- https://securitylab.github.com/research/in_the_wild_chrome_cve_2021_37975/ 

CVE-2019-13720

- https://www.exploit-db.com/exploits/50917

### Browser SBX

- [Renderer RCE -> Enable Mojo -> Browser Heap Spray + Browser UaF -> Fake Structures -> Fake VTables -> Browser RCE](https://googleprojectzero.blogspot.com/2019/04/virtually-unlimited-memory-escaping.html)

- [Renderer RCE -> Enable Mojo -> No-Sandbox Renderer RCE](https://blog.theori.io/cleanly-escaping-the-chrome-sandbox-1c38abd3c9cb)

### Some good stuff

- [Tiggering GCs in V8, Exploit stablization techniques (Chrome 90.0.4430.72)](https://tiszka.com/blog/CVE_2021_21225_exploit.html)

