# Current state of Chrome Exploitation (V8 Type Confusion/OOB-Writes?)

### Objective:

```
Bug -> Primatives -> RWX -> RCE 
```

- If you have arb r/w and you can leak the location of RWX, you can slowly write in your shellcode 4/8 bytes by 4/8 bytes

- On earlier versions of Chrome, where we could r/w the backing store of ArrayBuffers, we can simply change it to the location of the RWX space and abuse the native JavaScript functions such as `.set()` to quickly write in our shellcode

### RCE:

Prior to "Early 2018" (as per [phrack](http://www.phrack.org/issues/70/9.html))

- JIT functions are RWX

- We can JIT a function to create RWX space, before using our primatives to write shellcode and obtain RCE (ezpz)

- [Mitigation: R-X/RW-X](https://github.com/v8/v8/commit/14917b6531596d33590edb109ec14f6ca9b95536) (a.k.a [W^X](https://en.wikipedia.org/wiki/W%5EX))

    > Bypass #1: Bitmap flip FLAG_write_protect_code_memory via leaking V8 Isolate - need relative R/W, [see](https://tiszka.com/blog/CVE_2021_21225_exploit.html)

Prior to TPT

- Abuse WASM spaces which are RWX

- [Mitigation: kWebAssemblyCodeProtectionPku (Protects RWX WASM from being written)](https://starlabs.sg/blog/2022/12-the-hole-new-world-how-a-small-leak-will-sink-a-great-browser-cve-2021-38003/)

    > Bypass #1: Bitmap flip FLAG_write_protect_code_memory via OfflineAudioContext (set to 0) - need Arbitrary R/W, [see](https://tiszka.com/blog/CVE_2021_21225_exploit.html)

Prior to CPT

- JIT "Shellcoding"?

- Even though JIT code are R-X, we can spray an array of functions such as `const jit = () => { return [1.1, 2.2, 3.3, 4.4] }`

- Each float is 64 bits and we can "hide" shellcode in the floats before "jumping" from float to float in order to get a full RCE

- [Mitigation: CPT](https://docs.google.com/document/d/1CPs5PutbnmI-c5g7e_Td9CNGh5BvpLleKCqUnqmD82k/edit )

### Obtaining Arbitrary R/W

Prior to Chrome 80 as per [gpz](https://googleprojectzero.blogspot.com/2021/01/in-wild-series-chrome-exploits.html)

- Pointer Compression NOT used

- No V8 "sandbox" (pointer compression is not really a proper sandbox but it does ensure that if you write a backing store in a form of a compressed pointer such as the element or property pointers, your primatives can only work in the V8 heap space)

- We can easily obtain arbitrary r/w (ezpz)

Prior to ArrayBuffer sandboxing (Ubercage)

- In order to obtain arbitrary r/w, we need to be able to control raw pointers. A commonly abused raw pointer is backing stores in ArrayBuffer objects

- We can escalate sandboxed/compressed r/w into arbitrary r/w by reading and writing 64 bits into the compressed heap space of V8. If we have an OOB object, we can possibly abuse it to write to raw pointers as well (just like how we can write compressed pointers)

- [Mitigation: Sandboxifying BackingStores of ArrayBuffer objects](https://docs.google.com/document/d/1HSap8-J3HcrZvT7-5NsbYWcjfc0BVoops5TDHZNsnko/edit)

    > Bypass: JIT Shellcoding + Arbitrary R/W via TypedArrays (must be before CPT) [Technique #1 used in DiceCTF](https://anvbis.au/posts/code-execution-in-chromiums-v8-heap-sandbox/), [Another technique #1 used in DiceCTF](https://mem2019.github.io/jekyll/update/2022/02/06/DiceCTF-Memory-Hole.html)

    > Bypass: WASM imported_mutable_global raw pointer [Technique #2 used in DiceCTF](https://blog.kylebot.net/2022/02/06/DiceCTF-2022-memory-hole/), [Another technique #2 used in DiceCTF](https://anvbis.au/posts/exploring-historical-v8-heap-sandbox-escapes-i/)

    > Bypass: Somehow leak [@r14](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/codegen/x64/register-x64.h;l=239;drc=73b9a84755562357a94135b952f492d8c631410f) and add it to the **index** after applying the shifts. **Index** for ArrayBuffer object can be obtain via Sandbox read primative (Have not seen technique yet but maybe it's possible?)

### Current state of Chrome Exploitation (V8 UaF)

CVE-2019-5786

- https://blog.exodusintel.com/2019/03/20/cve-2019-5786-analysis-and-exploitation/

WebAudio CVE-2020-6449 

- https://www.anquanke.com/post/id/221043

- https://packetstormsecurity.com/files/172843/Chrome-WebAudio-Use-After-Free.html

- https://securitylab.github.com/research/CVE-2020-6449-exploit-chrome-uaf/ 

CVE-2021-37975

- https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2021/CVE-2021-37975.html

- https://securitylab.github.com/research/in_the_wild_chrome_cve_2021_37975/ 

CVE-2019-13720

- https://www.exploit-db.com/exploits/50917

### Ubercage SBX

https://blog.theori.io/a-deep-dive-into-v8-sandbox-escape-technique-used-in-in-the-wild-exploit-d5dcf30681d4

https://retr0.zip/blog/abusing-Liftoff-assembly-and-efficiently-escaping-from-sbx.html

https://medium.com/@numencyberlabs/use-wasm-to-bypass-latest-chrome-v8sbx-again-639c4c05b157

https://medium.com/@numencyberlabs/use-native-pointer-of-function-to-bypass-the-latest-chrome-v8-sandbox-exp-of-issue1378239-251d9c5b0d14

- Ubercage seems to be implemented from Chrome 103 and onwards for Windows platforms

    ![](./screenshots/ubercage_sandboxify_backingstores//Chrome_102.0.5005.63_ArrayBuffer_BackingStore.png)
    *Chrome 102.0.5005.63 (Last apprent version of Chrome before ArrayBuffer Backing Store were sandboxed)*

    ![](./screenshots/ubercage_sandboxify_backingstores//Chrome_104.0.5112.81_ArrayBuffer_BackingStore-2.png)
    *Chrome 104.0.5112.81*

### Browser SBX

- [Renderer RCE -> Enable Mojo -> Browser Heap Spray + Browser UaF -> Fake Structures -> Fake VTables -> Browser RCE](https://googleprojectzero.blogspot.com/2019/04/virtually-unlimited-memory-escaping.html)

- [Renderer RCE -> Enable Mojo -> No-Sandbox Renderer RCE](https://blog.theori.io/cleanly-escaping-the-chrome-sandbox-1c38abd3c9cb)

### Some good stuff

- [Tiggering GCs in V8, Exploit stablization techniques (Chrome 90.0.4430.72)](https://tiszka.com/blog/CVE_2021_21225_exploit.html)

# Compilation

### V8/Browser Exploits

[tianstcht](https://github.com/tianstcht/v8-exploit), [rycbar77](https://github.com/rycbar77/V8Exploits), [anvbis](https://github.com/anvbis/chrome_v8_ndays), [exd0tpy](https://github.com/exd0tpy/CTF-browser-challenges), [Geluchat](https://github.com/Geluchat/chrome_v8_exploit), [vngkv123](https://github.com/vngkv123/aSiagaming/tree/master), [m1ghtym0](https://github.com/m1ghtym0/browser-pwn), [Escapingbug](https://github.com/Escapingbug/awesome-browser-exploit), [cezary-sec](https://github.com/cezary-sec/awesome-browser-security)

### Others

[V8 Exploitation Series by MadStacks.dev](https://www.madstacks.dev/posts/V8-Exploitation-Series-Part-5/)

[Attacking JavaScript Engines in 2022](https://saelo.github.io/presentations/offensivecon_22_attacking_javascript_engines.pdf)

[Chrome Architecture Reading List for Vulnerability Researchers](https://zon8.re/posts/v8-chrome-architecture-reading-list-for-vulnerability-researchers/)

# V8 Bugs

### CVE-2017-XXXX

[CVE-2017-15399](https://blog.haboob.sa/blog/chrome-exploitation-an-old-but-good-case-study)

### CVE-2020-XXXX

[CVE-2020-6418 #1](https://starlabs.sg/blog/2022/12-deconstructing-and-exploiting-cve-2020-6418/), [CVE-2020-6418 #2](https://blog.exodusintel.com/2020/02/24/a-eulogy-for-patch-gapping-chrome/)

[issue-1126249](https://gist.github.com/hkraw/5ba2df87925fb7de8acc3c4bcec4774e)

### CVE-2021-XXXX

[CVE-2021-21156](https://packetstormsecurity.com/files/162579/Chrome-Array-Transfer-Bypass.html)

[CVE-2021-21220 #1](https://www.zerodayinitiative.com/blog/2021/12/6/two-birds-with-one-stone-an-introduction-to-v8-and-jit-exploitation), [CVE-2021-21220 #2](https://www.zerodayinitiative.com/blog/2021/12/8/understanding-the-root-cause-of-cve-2021-21220-a-chrome-bug-from-pwn2own-2021), [CVE-2021-21220 #3](https://www.zerodayinitiative.com/blog/2021/12/15/exploitation-of-cve-2021-21220-from-incorrect-jit-behavior-to-rce)

[CVE-2021-21225](https://tiszka.com/blog/CVE_2021_21225_exploit.html)

[CVE-2021-30632](https://securitylab.github.com/research/in_the_wild_chrome_cve_2021_30632/)

[CVE-2021-37975](https://securitylab.github.com/research/in_the_wild_chrome_cve_2021_37975/)

[Issue-1211215](https://blog.exodusintel.com/2023/05/16/google-chrome-v8-arrayshift-race-condition-remote-code-execution/)

### CVE-2023-XXXX

[CVE-2023-3079 #1](https://cwresearchlab.co.kr/entry/CVE-2023-3079-Bug-in-the-handling-of-the-arguments-object), [CVE-2023-3079 #2](https://blog.theori.io/chaining-n-days-to-compromise-all-part-1-chrome-renderer-rce-1afccf56721b). [CVE-2023-3079 #3](https://github.com/ret2eax/exploits/blob/main/CVE-2023-3079/debug/poc.js), [CVE-2023-3079 #4](https://github.com/vu-ls/Zenbleed-Chrome-PoC)

[CVE-2023-3420](https://github.blog/2023-09-26-getting-rce-in-chrome-with-incorrect-side-effect-in-the-jit-compiler/)

[CVE-2023-4069](https://github.blog/2023-10-17-getting-rce-in-chrome-with-incomplete-object-initialization-in-the-maglev-compiler/)

[CVE-2023-4427](https://github.com/tianstcht/CVE-2023-4427/blob/main/exp.html)

[CVE-2023-6702](https://github.com/kaist-hacking/CVE-2023-6702/blob/master/exploit.html)

[Issue-1472121 #1](https://cwresearchlab.co.kr/entry/Issue-1472121-Exploit-out-of-bound-CloneObjectIC-type-confusion), [Issue-1472121 #2](https://www.ctfiot.com/156419.html)

### CVE-2024-XXXX

[CVE-2024-0517](https://cwresearchlab.co.kr/entry/CVE-2024-0517-Out-of-Bounds-Write-in-V8)

# Chrome CTFs

[Google CTF 2018](https://eternalsakura13.com/2018/11/19/justintime/)

[Google CTF 2021](https://ptr-yudai.hatenablog.com/entry/2021/07/26/225308)

[TurboFlan](https://www.willsroot.io/2021/04/turboflan-picoctf-2021-writeup-v8.html)

[Krautflare](https://www.jaybosamiya.com/blog/2019/01/02/krautflare/)

[CTF 2019 - oob-v8](https://ir0nstone.gitbook.io/notes/types/browser-exploitation/ctf-2019-oob-v8)

[35C3 CTF](https://abiondo.me/2019/01/02/exploiting-math-expm1-v8/)

[0CTF 2020](https://blog.perfect.blue/Chromium-Fullchain)

[DiceCTF2022 #1](https://tttang.com/archive/1443/), [DiceCTF2022 #2](https://blog.kylebot.net/2022/02/06/DiceCTF-2022-memory-hole/#Escape-the-Cage), [DiceCTF2022 #3](https://jayl1n.github.io/2022/02/27/v8-sandbox-escape/), [DiceCTF2022 #4](https://mem2019.github.io/jekyll/update/2022/02/06/DiceCTF-Memory-Hole.html)

[openECSC](https://lyra.horse/blog/2024/05/exploiting-v8-at-openecsc/)

KITCTF 2022

picoctf-2021-kit-engine

picoctf-2021-horse-power

34C3 CTF v9

HITCON CTF 2022

RealWorldCTF Quals 2019

WCTF 2019 

# Renderer SBX

https://github.com/niklasb/hack2win-chrome

https://securitylab.github.com/research/one_day_short_of_a_fullchain_sbx/

https://blog.theori.io/cleanly-escaping-the-chrome-sandbox-1c38abd3c9cb

https://googleprojectzero.blogspot.com/2019/04/virtually-unlimited-memory-escaping.html

https://starlabs.sg/blog/2022/01-the-cat-escaped-from-the-chrome-sandbox/

https://github.com/emredavut/Chrome-Android-and-Windows-0day-RCE-SBX

https://securitylab.github.com/research/chrome_sbx_java/

https://robertchen.cc/blog/2021/07/07/sbx-intro

https://robertchen.cc/blog/2021/02/07/adult-csp

# Ubercage SBX

[Liftoff](https://retr0.zip/blog/abusing-Liftoff-assembly-and-efficiently-escaping-from-sbx.html)

[Shellcode Spraying via WAT](https://github.com/candymate/csed499I-01/blob/master/README.md)

[Shellcode Spraying via JIT](https://anvbis.au/posts/code-execution-in-chromiums-v8-heap-sandbox/)

[imported_function_targets](https://blog.theori.io/a-deep-dive-into-v8-sandbox-escape-technique-used-in-in-the-wild-exploit-d5dcf30681d4)

[imported_mutable_globals](https://anvbis.au/posts/exploring-historical-v8-heap-sandbox-escapes-i/)

[tiering_budget_array](https://issues.chromium.org/issues/40068627)

# Others Interesting Reports

[Exploitable Sparkplug Bug?](https://bugs.chromium.org/p/chromium/issues/detail?id=1179595)

[Rogue in-flight Data Load (RIDL) Chrome SBX](https://googleprojectzero.blogspot.com/2020/02/escaping-chrome-sandbox-with-ridl.html)