# Windows Heap Internals

Everything about windows heap allocation, free, algorithms etc... Things to note:

1. Heap manager changes from version to version of windows

2. Heap algorithms are usually implemented in undocumented ntdll.dll

References:

- https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/-heap

- https://techcommunity.microsoft.com/t5/ask-the-performance-team/what-a-heap-of-part-one/ba-p/372424

- https://en.wikipedia.org/wiki/Free_list

- https://pages.cs.wisc.edu/~fischer/cs536.s06/course.hold/html/NOTES/12.HEAP-MANAGEMENT.html

### Windows XP Heap Architecture:

- References:

    1. [informit article part 1](https://www.informit.com/articles/article.aspx?p=1081496), [informit article part 2](https://www.informit.com/articles/article.aspx?p=1081496&seqNum=2), [informit article part 3](https://www.informit.com/articles/article.aspx?p=1081496&seqNum=3)

    2. [Windows Heap Overflow VEH Exploitation](https://rce4fun.blogspot.com/2014/05/windows-heap-overflow-exploitation.html)

- Frontend Heap Manager: 

	1. LAL (singly linked list of free blocks)

		- If no free chunks for a bucket 0 - 127, then it will point to NULL

		- When there is an allocation, then the bucket will point to the pointer to the allocated memory, and that will point to NULL

        - From windows 7 and onwards, there is no support and hence use for LALs (maybe even Windows XP)
    
    2. LFH

        - Not many detailed research articles on LFH implementations in Windows XP/vista, also not necessary for Windows XP Heap Exploitation hence screw it

- Backend Heap Manager:

	1. FreeList (doubly linked list of free blocks)

		- Track freed memory in the heap

		- FreeList 2 - 127 are dedicated free list, free chunks in this list have sizes n * 8

        - FreeList 1 is unused 

		- FreeList 0 store free chunks with sizes >= 1024

		- Bitmap used to track whats used or not

- Others:

    1. LAL and FreeList can both service requests for <= 1024 bytes

- Debugging/Analysis (write up a simple c++ program which allocs and frees heap blocks of different sizes):

    1. Download symbols

        ```
        0:001> .reload /f
        Reloading current modules
        .
        SYMSRV:  c:\symbols\HeapAllocationAndFree.pdb\67BE74B889BE411492FEF1ECE9743B852\HeapAllocationAndFree.pdb not found
        SYMSRV:  http://msdl.microsoft.com/download/symbols/HeapAllocationAndFree.pdb/67BE74B889BE411492FEF1ECE9743B852/HeapAllocationAndFree.pdb not found
        *** WARNING: Unable to verify checksum for C:\Documents and Settings\Administrator\Desktop\Heap Internals\HeapInternals\Debug\HeapAllocationAndFree.exe
        DBGHELP: HeapAllocationAndFree - private symbols & lines 
                C:\Documents and Settings\Administrator\Desktop\Heap Internals\HeapInternals\Debug\HeapAllocationAndFree.pdb
        .
        SYMSRV:  c:\symbols\msvcr100d.i386.pdb\9E26F0DD2C2543B99754DB8B9BA5F8681\msvcr100d.i386.pdb not found
        SYMSRV:  http://msdl.microsoft.com/download/symbols/msvcr100d.i386.pdb/9E26F0DD2C2543B99754DB8B9BA5F8681/msvcr100d.i386.pdb not found
        DBGHELP: C:\WINDOWS\system32\msvcr100d.i386.pdb - file not found
        DBGHELP: msvcr100d.i386.pdb - file not found
        *** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\WINDOWS\system32\MSVCR100D.dll - 
        DBGHELP: MSVCR100D - export symbols
        .
        SYMSRV:  c:\symbols\msvcp100d.i386.pdb\27DBD64D923C447594980A3F48708A7D1\msvcp100d.i386.pdb not found
        SYMSRV:  http://msdl.microsoft.com/download/symbols/msvcp100d.i386.pdb/27DBD64D923C447594980A3F48708A7D1/msvcp100d.i386.pdb not found
        DBGHELP: C:\WINDOWS\system32\msvcp100d.i386.pdb - file not found
        DBGHELP: msvcp100d.i386.pdb - file not found
        *** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\WINDOWS\system32\MSVCP100D.dll - 
        DBGHELP: MSVCP100D - export symbols
        .
        SYMSRV:  c:\symbols\kernel32.pdb\0B1484F414A1463EAFF5680AA33631792\kernel32.pdb not found
        SYMSRV:  http://msdl.microsoft.com/download/symbols/kernel32.pdb/0B1484F414A1463EAFF5680AA33631792/kernel32.pdb not found
        DBGHELP: C:\WINDOWS\system32\kernel32.pdb - file not found
        DBGHELP: kernel32.pdb - file not found
        *** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\WINDOWS\system32\kernel32.dll - 
        DBGHELP: kernel32 - export symbols
        .
        DBGHELP: ntdll - public symbols  
                c:\symbols\ntdll.pdb\E62AEBA49D7048669405A13F1D46A57E2\ntdll.pdb
        ```

        - Manually download it based on logs (to generate logs, run `.symfix noisy` `!sym noisy` or some shit) (e.g. `http://msdl.microsoft.com/download/symbols/ntdll.pdb/E62AEBA49D7048669405A13F1D46A57E2/ntdll.pdb`)

        - Set the appropriate sympath: `SRV*C:\Symbols*http://msdl.microsoft.com/download/symbols`; `.reload /f`

        - https://learn.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-list_entry

    2. Dump peb

        ```
        0:001> dt _PEB @$peb
        ntdll!_PEB
            +0x000 InheritedAddressSpace : 0 ''
            +0x001 ReadImageFileExecOptions : 0 ''
            +0x002 BeingDebugged    : 0x1 ''
            +0x003 SpareBool        : 0 ''
            +0x004 Mutant           : 0xffffffff Void
            +0x008 ImageBaseAddress : 0x00400000 Void
            +0x00c Ldr              : 0x00251ea0 _PEB_LDR_DATA
            +0x010 ProcessParameters : 0x00020000 _RTL_USER_PROCESS_PARAMETERS
            +0x014 SubSystemData    : (null) 
            +0x018 ProcessHeap      : 0x00150000 Void
            +0x01c FastPebLock      : 0x7c980620 _RTL_CRITICAL_SECTION
            +0x020 FastPebLockRoutine : 0x7c901000 Void
            +0x024 FastPebUnlockRoutine : 0x7c9010e0 Void
            +0x028 EnvironmentUpdateCount : 1
            +0x02c KernelCallbackTable : (null) 
            +0x030 SystemReserved   : [1] 0
            +0x034 AtlThunkSListPtr32 : 0
            +0x038 FreeList         : (null) 
            +0x03c TlsExpansionCounter : 0
            +0x040 TlsBitmap        : 0x7c9805e0 Void
            +0x044 TlsBitmapBits    : [2] 7
            +0x04c ReadOnlySharedMemoryBase : 0x7f6f0000 Void
            +0x050 ReadOnlySharedMemoryHeap : 0x7f6f0000 Void
            +0x054 ReadOnlyStaticServerData : 0x7f6f0688  -> (null) 
            +0x058 AnsiCodePageData : 0x7ffb0000 Void
            +0x05c OemCodePageData  : 0x7ffc1000 Void
            +0x060 UnicodeCaseTableData : 0x7ffd2000 Void
            +0x064 NumberOfProcessors : 1
            +0x068 NtGlobalFlag     : 0x70
            +0x070 CriticalSectionTimeout : _LARGE_INTEGER 0xffffe86d`079b8000
            +0x078 HeapSegmentReserve : 0x100000
            +0x07c HeapSegmentCommit : 0x2000
            +0x080 HeapDeCommitTotalFreeThreshold : 0x10000
            +0x084 HeapDeCommitFreeBlockThreshold : 0x1000
            +0x088 NumberOfHeaps    : 4
            +0x08c MaximumNumberOfHeaps : 0x10
            +0x090 ProcessHeaps     : 0x7c97ffe0  -> 0x00150000 Void
            +0x094 GdiSharedHandleTable : (null) 
            +0x098 ProcessStarterHelper : (null) 
            +0x09c GdiDCAttributeList : 0
            +0x0a0 LoaderLock       : 0x7c97e174 Void
            +0x0a4 OSMajorVersion   : 5
            +0x0a8 OSMinorVersion   : 1
            +0x0ac OSBuildNumber    : 0xa28
            +0x0ae OSCSDVersion     : 0x300
            +0x0b0 OSPlatformId     : 2
            +0x0b4 ImageSubsystem   : 3
            +0x0b8 ImageSubsystemMajorVersion : 5
            +0x0bc ImageSubsystemMinorVersion : 1
            +0x0c0 ImageProcessAffinityMask : 0
            +0x0c4 GdiHandleBuffer  : [34] 0
            +0x14c PostProcessInitRoutine : (null) 
            +0x150 TlsExpansionBitmap : 0x7c9805d8 Void
            +0x154 TlsExpansionBitmapBits : [32] 0
            +0x1d4 SessionId        : 0
            +0x1d8 AppCompatFlags   : _ULARGE_INTEGER 0x0
            +0x1e0 AppCompatFlagsUser : _ULARGE_INTEGER 0x0
            +0x1e8 pShimData        : (null) 
            +0x1ec AppCompatInfo    : (null) 
            +0x1f0 CSDVersion       : _UNICODE_STRING "Service Pack 3"
            +0x1f8 ActivationContextData : 0x00140000 Void
            +0x1fc ProcessAssemblyStorageMap : (null) 
            +0x200 SystemDefaultActivationContextData : 0x00130000 Void
            +0x204 SystemAssemblyStorageMap : (null) 
            +0x208 MinimumStackCommit : 0
        0:001> dd 0x7c97ffe0  
        7c97ffe0  00150000 00250000 00260000 00340000
        7c97fff0  00000000 00000000 00000000 00000000
        7c980000  00000000 00000000 00000000 00000000
        7c980010  00000000 00000000 00000000 00000000
        7c980020  01fe01fc 00020498 00000001 7c9b2000
        7c980030  7ffd2de6 00000001 00000005 00000001
        7c980040  ffff45ee 00000000 003a0043 0057005c
        7c980050  004e0049 004f0044 00530057 0073005c
        ```
    
    3. Dump heap structure

        ```
        0:001> dt _HEAP 0x00150000
        ...
            +0x178 FreeLists        : [128] _LIST_ENTRY [ 0x153b40 - 0x153b40 ]
        ...
        0:001> dt _LIST_ENTRY 0x00150000+0x178
        HeapAllocationAndFree!_LIST_ENTRY
            [ 0x153b40 - 0x153b40 ]
                +0x000 Flink            : 0x00153b40 _LIST_ENTRY [ 0x150178 - 0x150178 ]
                +0x004 Blink            : 0x00153b40 _LIST_ENTRY [ 0x150178 - 0x150178 ]
        0:001> dd 0x00150000 + 178
        00150178  00150178 00150178 00150180 00150180
        00150188  00150188 00150188 00150190 00150190
        00150198  00150198 00150198 001501a0 001501a0
        001501a8  001501a8 001501a8 001501b0 001501b0
        001501b8  001501b8 001501b8 001501c0 001501c0
        001501c8  001501c8 001501c8 001501d0 001501d0
        001501d8  001501d8 001501d8 001501e0 001501e0
        001501e8  001501e8 001501e8 001501f0 001501f0
        ```

    4. Analyse heap allocations

        ```
        0:001> dd 152c40
        00152c40  baadf00d baadf00d baadf00d baadf00d
        00152c50  abababab abababab 00000000 00000000
        00152c60  00050074 00ee14ee 00150518 00150518
        00152c70  feeefeee feeefeee feeefeee feeefeee
        00152c80  feeefeee feeefeee feeefeee feeefeee
        00152c90  feeefeee feeefeee feeefeee feeefeee
        00152ca0  feeefeee feeefeee feeefeee feeefeee
        00152cb0  feeefeee feeefeee feeefeee feeefeee
        ```

        - [here](https://forum.lazarus.freepascal.org/index.php?topic=42483.0) and [here](https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_debug_values) for more information on various tags (e.g. `baadf00d`)

        - Take note that the tags are only used if the program is being DEBUGGED (use immunity's !hidedebug module to disable)

        ```
        0:001> dd 152c40
        00152c40  baadf00d baadf00d baadf00d baadf00d
        00152c50  abababab abababab 00000000 00000000
        00152c60  000500bf 001c0771 baadf00d baadf00d
        00152c70  baadf00d baadf00d baadf00d baadf00d
        00152c80  baadf00d baadf00d baadf00d baadf00d
        00152c90  baadf00d baadf00d baadf00d baadf00d
        00152ca0  baadf00d baadf00d baadf00d baadf00d
        00152cb0  baadf00d baadf00d baadf00d baadf00d
        0:001> dd 152c68
        00152c68  baadf00d baadf00d baadf00d baadf00d
        00152c78  baadf00d baadf00d baadf00d baadf00d
        00152c88  baadf00d baadf00d baadf00d baadf00d
        00152c98  baadf00d baadf00d baadf00d baadf00d
        00152ca8  baadf00d baadf00d baadf00d baadf00d
        00152cb8  baadf00d baadf00d baadf00d baadf00d
        00152cc8  baadf00d baadf00d baadf00d baadf00d
        00152cd8  baadf00d baadf00d baadf00d baadf00d
        0:001> ? 0n1500
        Evaluate expression: 1500 = 000005dc
        0:001> dd 152c68 + 5dc
        00153244  abababab abababab feeefeee 00000000
        00153254  00000000 00bf01b5 00ee14ee 00150178
        00153264  00150178 feeefeee feeefeee feeefeee
        00153274  feeefeee feeefeee feeefeee feeefeee
        00153284  feeefeee feeefeee feeefeee feeefeee
        00153294  feeefeee feeefeee feeefeee feeefeee
        001532a4  feeefeee feeefeee feeefeee feeefeee
        001532b4  feeefeee feeefeee feeefeee feeefeee
        0:001> dd 152c68 + 5dc -4
        00153240  baadf00d abababab abababab feeefeee
        00153250  00000000 00000000 00bf01b5 00ee14ee
        00153260  00150178 00150178 feeefeee feeefeee
        00153270  feeefeee feeefeee feeefeee feeefeee
        00153280  feeefeee feeefeee feeefeee feeefeee
        00153290  feeefeee feeefeee feeefeee feeefeee
        001532a0  feeefeee feeefeee feeefeee feeefeee
        001532b0  feeefeee feeefeee feeefeee feeefeee
        ```

        - After you run heapalloc, your allocated memory size (16 and 1500 respectively is marked with baadfood)

    5. Analyse heap allocations: use 5 allocations of 16 bytes and 5 allocations of 1500 bytes, then free them respectively

        ```
        0:001> dt _HEAP_SEGMENT 150640
        ntdll!_HEAP_SEGMENT
            +0x000 Entry            : _HEAP_ENTRY
            +0x008 Signature        : 0xffeeffee
            +0x00c Flags            : 0
            +0x010 Heap             : 0x00150000 _HEAP
            +0x014 LargestUnCommittedRange : 0xfc000
            +0x018 BaseAddress      : 0x00150000 Void
            +0x01c NumberOfPages    : 0x100
            +0x020 FirstEntry       : 0x00150680 _HEAP_ENTRY
            +0x024 LastValidEntry   : 0x00250000 _HEAP_ENTRY
            +0x028 NumberOfUnCommittedPages : 0xfc
            +0x02c NumberOfUnCommittedRanges : 1
            +0x030 UnCommittedRanges : 0x00150588 _HEAP_UNCOMMMTTED_RANGE
            +0x034 AllocatorBackTraceIndex : 0
            +0x036 Reserved         : 0
            +0x038 LastEntryInSegment : 0x00153540 _HEAP_ENTRY
        0:001> dd 150688
        00150688  00000000 00000000 01000004 00000000
        00150698  00000000 00000000 00000000 00000000
        001506a8  00000000 00000011 00000000 00000000
        001506b8  00000000 00000000 01000004 00000000
        001506c8  00000000 00000000 00000000 00000000
        001506d8  00000000 00000000 00000000 00000000
        001506e8  00000000 00000000 01000004 00000000
        001506f8  00000000 00000000 00000000 00000000
        0:001> dd 150178
        00150178  00153548 00153548 00150180 00150180
        00150188  00150188 00150188 00150190 00150190
        00150198  00150198 00150198 001501a0 001501a0
        001501a8  001501a8 001501a8 001501b0 001501b0
        001501b8  001501b8 001501b8 001501c0 001501c0
        001501c8  001501c8 001501c8 001501d0 001501d0
        001501d8  001501d8 001501d8 001501e0 001501e0
        001501e8  001501e8 001501e8 001501f0 001501f0
        0:001> dt _HEAP_ENTRY 150680
        ntdll!_HEAP_ENTRY
            +0x000 Size             : 0x301
            +0x002 PreviousSize     : 8
            +0x000 SubSegmentCode   : 0x00080301 Void
            +0x004 SmallTagIndex    : 0xf9 ''
            +0x005 Flags            : 0x1 ''
            +0x006 UnusedBytes      : 0x8 ''
            +0x007 SegmentIndex     : 0 '
        0:001> dt _HEAP_ENTRY 150680+301*8+42*8+45*8+6*8+3*8+9*8+46*8+5c*8+64*8+64*8+6*8+6*8+9*8+9*8+3c*8+17*8+1f*8+44*8
        ntdll!_HEAP_ENTRY
            +0x000 Size             : 0x158
            +0x002 PreviousSize     : 0x44
            +0x000 SubSegmentCode   : 0x00440158 Void
            +0x004 SmallTagIndex    : 0 ''
            +0x005 Flags            : 0x10 ''
            +0x006 UnusedBytes      : 0 ''
            +0x007 SegmentIndex     : 0 ''
        ```

        - Before any allocation is done

        - Heap base is at 150000

        - Heap segment is at 150640 

        - First entry is at 150680

        ```
        0:001> dt _HEAP_ENTRY 150680+301*8+42*8+45*8+6*8+3*8+9*8+46*8+5c*8+64*8+64*8+6*8+6*8+9*8+9*8+3c*8+17*8+1f*8+44*8
        ntdll!_HEAP_ENTRY
            +0x000 Size             : 3
            +0x002 PreviousSize     : 0x44
            +0x000 SubSegmentCode   : 0x00440003 Void
            +0x004 SmallTagIndex    : 0x81 ''
            +0x005 Flags            : 0x1 ''
            +0x006 UnusedBytes      : 0x8 ''
            +0x007 SegmentIndex     : 0 ''
        0:001> dt _HEAP_ENTRY 150680+301*8+42*8+45*8+6*8+3*8+9*8+46*8+5c*8+64*8+64*8+6*8+6*8+9*8+9*8+3c*8+17*8+1f*8+44*8+3*8
        ntdll!_HEAP_ENTRY
            +0x000 Size             : 0x155
            +0x002 PreviousSize     : 3
            +0x000 SubSegmentCode   : 0x00030155 Void
            +0x004 SmallTagIndex    : 0 ''
            +0x005 Flags            : 0x10 ''
            +0x006 UnusedBytes      : 0 ''
            +0x007 SegmentIndex     : 0 ''
        0:001> ? 0x8*0x3-8
        Evaluate expression: 16 = 00000010
        0:001> dd 150178
        00150178  00153560 00153560 00150180 00150180
        00150188  00150188 00150188 00150190 00150190
        00150198  00150198 00150198 001501a0 001501a0
        001501a8  001501a8 001501a8 001501b0 001501b0
        001501b8  001501b8 001501b8 001501c0 001501c0
        001501c8  001501c8 001501c8 001501d0 001501d0
        001501d8  001501d8 001501d8 001501e0 001501e0
        001501e8  001501e8 001501e8 001501f0 001501f0
        0:001> dt _HEAP_ENTRY 00153560-8
        ntdll!_HEAP_ENTRY
            +0x000 Size             : 0x155
            +0x002 PreviousSize     : 3
            +0x000 SubSegmentCode   : 0x00030155 Void
            +0x004 SmallTagIndex    : 0 ''
            +0x005 Flags            : 0x10 ''
            +0x006 UnusedBytes      : 0 ''
            +0x007 SegmentIndex     : 0 ''
        0:001> dt _HEAP_ENTRY 00153548-8 >> 153548 is the address of the first allocation
        ntdll!_HEAP_ENTRY
            +0x000 Size             : 3
            +0x002 PreviousSize     : 0x44
            +0x000 SubSegmentCode   : 0x00440003 Void
            +0x004 SmallTagIndex    : 0x81 ''
            +0x005 Flags            : 0x1 ''
            +0x006 UnusedBytes      : 0x8 ''
            +0x007 SegmentIndex     : 0 ''
        ```

        - After a 16 byte allocation, we can see a difference in terms of the size of the last allocation

        - Strangely, freelist[0] is being used to handle all the 16 bytes allocation

        - We can use `!heap -stat -h 150000`, `!heap -a 150000`, `!heap -flt s 0n16` to track heap blocks also

        ```
        0:001> dt _HEAP_ENTRY 150680+301*8+42*8+45*8+6*8+3*8+9*8+46*8+5c*8+64*8+64*8+6*8+6*8+9*8+9*8+3c*8+17*8+1f*8+44*8+3*8+3*8+3*8+3*8+3*8
        ntdll!_HEAP_ENTRY
            +0x000 Size             : 0x149
            +0x002 PreviousSize     : 3
            +0x000 SubSegmentCode   : 0x00030149 Void
            +0x004 SmallTagIndex    : 0 ''
            +0x005 Flags            : 0x10 ''
            +0x006 UnusedBytes      : 0 ''
            +0x007 SegmentIndex     : 0 ''
        0:001> dd 150178
        00150178  001535c0 001535c0 00150180 00150180
        00150188  00150188 00150188 00150190 00150190
        00150198  00150198 00150198 001501a0 001501a0
        001501a8  001501a8 001501a8 001501b0 001501b0
        001501b8  001501b8 001501b8 001501c0 001501c0
        001501c8  001501c8 001501c8 001501d0 001501d0
        001501d8  001501d8 001501d8 001501e0 001501e0
        001501e8  001501e8 001501e8 001501f0 001501f0
        0:001> dd 150688
        00150688  00000000 00000000 01000004 00000000
        00150698  00000000 00000000 00000000 00000000
        001506a8  00000000 00000016 00000000 00000000
        001506b8  00000000 00000000 01000004 00000000
        001506c8  00000000 00000000 00000000 00000000
        001506d8  00000000 00000000 00000000 00000000
        001506e8  00000000 00000000 01000004 00000000
        001506f8  00000000 00000000 00000000 00000000
        ```

        - After 5 allocations...

        ```

        0:001> dt _HEAP_ENTRY 150680+301*8+42*8+45*8+6*8+3*8+9*8+46*8+5c*8+64*8+64*8+6*8+6*8+9*8+9*8+3c*8+17*8+1f*8+44*8+3*8+3*8+3*8+3*8+3*8+bd*8
        ntdll!_HEAP_ENTRY
            +0x000 Size             : 0x8c
            +0x002 PreviousSize     : 0xbd
            +0x000 SubSegmentCode   : 0x00bd008c Void
            +0x004 SmallTagIndex    : 0 ''
            +0x005 Flags            : 0x10 ''
            +0x006 UnusedBytes      : 0 ''
            +0x007 SegmentIndex     : 0 ''
        ```

        - Let's see how the next allocation would be like, as we do not have enough space to perform the remaining 4 allocations of 1500 bytes

        ```
        0:001> dt _HEAP_ENTRY 150680+301*8+42*8+45*8+6*8+3*8+9*8+46*8+5c*8+64*8+64*8+6*8+6*8+9*8+9*8+3c*8+17*8+1f*8+44*8+3*8+3*8+3*8+3*8+3*8+bd*8+bd*8
        ntdll!_HEAP_ENTRY
            +0x000 Size             : 0x1cf
            +0x002 PreviousSize     : 0xbd
            +0x000 SubSegmentCode   : 0x00bd01cf Void
            +0x004 SmallTagIndex    : 0 ''
            +0x005 Flags            : 0x10 ''
            +0x006 UnusedBytes      : 0 ''
            +0x007 SegmentIndex     : 0 ''
        ```

        - Most likely what happened was that heap manager requested for more memory to handle the upcoming 1500 bytes allocation request

        ```
        0:001> dd 150178
        00150178  00155348 00155348 00150180 00150180
        00150188  00150188 00150188 00150190 00150190
        00150198  00150198 00150198 001501a0 001501a0
        001501a8  001501a8 001501a8 001501b0 001501b0
        001501b8  001501b8 001501b8 001501c0 001501c0
        001501c8  001501c8 001501c8 001501d0 001501d0
        001501d8  001501d8 001501d8 001501e0 001501e0
        001501e8  001501e8 001501e8 001501f0 001501f0
        0:001> dd 150688 L80
        00150688  00000000 00000000 01000004 00000000
        00150698  00000000 00000000 00000000 00000000
        001506a8  00000000 00000016 00000000 00000000
        001506b8  00000000 00000000 01000004 00000000
        001506c8  00000000 00000000 00000000 00000000
        001506d8  00000000 00000005 00000000 00000000
        001506e8  00000000 00000000 01000004 00000000
        001506f8  00000000 00000000 00000000 00000000
        00150708  00000000 00000000 00000000 00000000
        00150718  00000000 00010000 01000004 00000007
        00150728  00000006 00000001 00000000 00000000
        00150738  00000000 00000000 00000000 00000000
        00150748  00000000 00000000 01000004 00000000
        00150758  00000000 00000000 00000000 00000000
        00150768  00000000 00000000 00000000 00000000
        00150778  00000000 00000000 01000004 00000000
        00150788  00000000 00000000 00000000 00000000
        00150798  00000000 00000000 00000000 00000000
        001507a8  00000000 00000000 01000004 00000003
        001507b8  00000003 00000000 00000000 00000000
        001507c8  00000000 00000000 00000000 00000000
        001507d8  00000000 00000000 01000004 00000000
        001507e8  00000000 00000000 00000000 00000000
        001507f8  00000000 00000000 00000000 00000000
        00150808  00000000 00000000 01000004 00000000
        00150818  00000000 00000000 00000000 00000000
        00150828  00000000 00000000 00000000 00000000
        00150838  00000000 00000000 01000004 00000003
        00150848  00000003 00000000 00000000 00000000
        00150858  00000000 00000000 00000000 00000000
        00150868  00000000 00000000 01000004 00000000
        00150878  00000000 00000000 00000000 00000000
        ```

        - After heap allocations are done, now to analyse frees

        ```
        0:001> dd 150688 L80
        00150688  00000000 00000000 01000004 00000000
        00150698  00000000 00000000 00000000 00000000
        001506a8  00000000 00000016 00000000 00000000
        001506b8  00000000 00000000 01000004 00000000
        001506c8  00000000 00000000 00000000 00000000
        001506d8  00000000 00000005 00000000 00000000
        001506e8  00000000 00000000 01000004 00000000
        001506f8  00000000 00000000 00000000 00000000
        00150708  00000000 00000000 00000000 00000000
        00150718  00153548 00020001 01000004 00000007
        0:001> dd 150178
        00150178  00155348 00155348 00150180 00150180
        00150188  00150188 00150188 00150190 00150190
        00150198  00150198 00150198 001501a0 001501a0
        001501a8  001501a8 001501a8 001501b0 001501b0
        001501b8  001501b8 001501b8 001501c0 001501c0
        001501c8  001501c8 001501c8 001501d0 001501d0
        001501d8  001501d8 001501d8 001501e0 001501e0
        001501e8  001501e8 001501e8 001501f0 001501f0
        ```

        - After one free, we see that the free block goes to LAL

        ```
        0:001> dd 150178
        00150178  00155348 00155348 00150180 00150180
        00150188  00150188 00150188 001535a8 001535a8
        00150198  00150198 00150198 001501a0 001501a0
        001501a8  001501a8 001501a8 001501b0 001501b0
        001501b8  001501b8 001501b8 001501c0 001501c0
        001501c8  001501c8 001501c8 001501d0 001501d0
        001501d8  001501d8 001501d8 001501e0 001501e0
        001501e8  001501e8 001501e8 001501f0 001501f0
        ```

        - Only at the fifth free onwards, does it go to the FreeList

        ```
        0:001> dd 150178
        00150178  001535a8 00155348 00150180 00150180
        00150188  00150188 00150188 00150190 00150190
        00150198  00150198 00150198 001501a0 001501a0
        001501a8  001501a8 001501a8 001501b0 001501b0
        001501b8  001501b8 001501b8 001501c0 001501c0
        001501c8  001501c8 001501c8 001501d0 001501d0
        001501d8  001501d8 001501d8 001501e0 001501e0
        001501e8  001501e8 001501e8 001501f0 001501f0
        ```

        - First free of 1500 blocks, Freelist[3] empties and goes to FreeList[0] with the 1500 bytes free block

        ```
        0:001> dd 001535a8 -8
        001535a0  0003017d 0008008e 00155348 00150178
        001535b0  00000000 00000000 000300bd 000c018d
        001535c0  00150178 00150178 00000000 00000000
        001535d0  00000000 00000000 00000000 00000000
        001535e0  00000000 00000000 00000000 00000000
        001535f0  00000000 00000000 00000000 00000000
        00153600  00000000 00000000 00000000 00000000
        00153610  00000000 00000000 00000000 00000000
        ```
        ```
        0:001> dd 001535a8 -8
        001535a0  0003023a 0008008e 00150178 00155348
        001535b0  00000000 00000000 000300bd 000c018d
        001535c0  00150178 00150178 00000000 00000000
        001535d0  00000000 00000000 00000000 00000000
        001535e0  00000000 00000000 00000000 00000000
        001535f0  00000000 00000000 00000000 00000000
        00153600  00000000 00000000 00000000 00000000
        00153610  00000000 00000000 00000000 00000000
        ```

        - Next few freed 1500 blocks goes to the same Freelist[0] block, with the self size propety increasing

        ```
        0:001> dd 150688 L40
        00150688  00000000 00000000 01000004 00000000
        00150698  00000000 00000000 00000000 00000000
        001506a8  00000000 0000001b 00000001 00000000
        001506b8  00000000 00000000 01000004 00000000
        001506c8  00000000 00000000 00000000 00000000
        001506d8  00000000 00000000 00000000 00000000
        001506e8  00000000 00000000 01000004 00000000
        001506f8  00000000 00000000 00000000 00000000
        00150708  00000000 00000000 00000000 00000000
        00150718  00153590 00050004 01000004 00000007
        00150728  00000006 00000006 00000001 00000000
        00150738  00000000 00000000 00000000 00000000
        00150748  001535c0 00010001 01000004 00000005
        00150758  00000005 00000001 00000000 00000000
        00150768  00000000 00000000 00000000 00000000
        00150778  00000000 00000000 01000004 00000000
        ```

        - If we set 1500 to 24 bytes, we see that the first free of 24 bytes will go to LAL

### Windows 7 Low Fragmentation Heap:

References:

- [Understanding the LFH (on windows 7)](https://illmatics.com/Understanding_the_LFH.pdf)

Changes in backend manager from Windows XP/Vista:

- No Dedicated FreeList in Windows 7 (e.g. FreeList[2] - FreeList[127])

- Each BlockIndex maintains its own ListHints which points to FreeList (similar to how FreeLists works)

- If there is no ExtendedLookup, then all chunks of size larger or equal to BlockIndex->ArraySize - 1 (0x80-1 or 0x800-1) is stored in ascending order in FreeList[ArraySize-BaseIndex-1]

    ```
    +0x000 ExtendedLookup : Ptr32 _HEAP_LIST_LOOKUP
    +0x004 ArraySize : Uint4B : highest block it will track (either 0x80 or 0x800), any higher go to ListHint
    +0x008 ExtraItem : Uint4B
    +0x00c ItemCount : Uint4B
    +0x010 OutOfRangeItems : Uint4B : number of chunks in FreeList[0]-like structure which is located at FreeList[ArraySize-BaseIndex-1]
    +0x014 BaseIndex : Uint4B : offsets to find ListHints (e.g. BaseIndex=0x0 for first BlockIndex cause it manages chunks from 0x0-0x80, BaseIndex=0x80 for second BlockIndex)
    +0x018 ListHead : Ptr32 _LIST_ENTRY
    +0x01c ListsInUseUlong : Ptr32 Uint4B
    +0x020 ListHints : Ptr32 Ptr32 _LIST_ENTRY
    ```

    ```
    ListHints: 0x150184

    0x150184 FreeList[0]: 0x00 bytes
    0x15018c FreeList[1]: 0x08 bytes
    0x150194 FreeList[2]: 0x10 bytes
    0x15019c FreeList[3]: 0x18 bytes
    0x1501a4 FreeList[4]: 0x20 bytes
    0x1501ac FreeList[5]: 0x28 bytes
    0x1501b4 FreeList[6]: 0x30 bytes
    0x1501bc FreeList[7]: 0x38 bytes
    ...
    0x1501bc FreeList[7f]: 0x38f1 bytes
    ```

- The way freelists are structured are also different, especially regarding the [sentinal nodes](https://www.geeksforgeeks.org/doubly-linked-list-using-sentinel-nodes/) of the doubly linked list freelist

    ```
    windows xp:
        freelist[0] <-> chunka <-> freelist[0]: freelist[0] are considered sentinal nodes

    windows 7:
        _HEAP=>FreeList <-> chunka <-> chunkb <-> chunkc <-> _HEAP=>FreeList
        BlocksIndex[0]=>FreeList[n] -> chunka
        BlocksIndex[0]=>FreeList[n+1] -> chunkc
    ```

Data Structures:

- _LFH_HEAP: Information of initialised LFH

    1. _HEAP_BUCKET: Information for particular heap bucket index (there are 128 heap buckets indices)

    2. _HEAP_LOCAL_DATA: Information for each heap subsegment (_HEAP_LOCAL_SEGMENT_INFO)

    3. _USER_MEMORY_CACHE_ENTRY: Information on previously used memory chunks 

- _HEAP_LOCAL_DATA: provide information of SubSegment information to LFH

    1. DeletedSubSegments (for SubSegment creation when LFH is to manage an allocation)

    2. _LFH_BLOCK_ZONE: Track memory used to serve heap allocations

        ```
        +0x000 ListEntry : _LIST_ENTRY – A linked list of _LFH_BLOCK_ZONE structures
        +0x008 FreePointer : Ptr32 Void – This will hold a pointer to memory that can be used by a _HEAP_SUBSEGMENT
        +0x00c Limit : Ptr32 Void - points to the last _LFH_BLOCK_ZONE structure
        ```

    3. _HEAP_LOCAL_SEGMENT_INFO: Information of each 128 heapsubsegment and the available sizes for LFH to manage (size allocation for 0x? bytes will be serviced by LFH if activated and ready by SubSegment[?])

- _HEAP_LOCAL_SEGMENT_INFO:

    1. Hint PTR: Points to a SubSegment _HEAP_SUBSEGMENT which was been FREED

    2. Active PTR: Points to a SubSegment _HEAP_SUBSEGMENT which will be used to service memory request

    3. LocalData PTR: Points to a _HEAP_LOCAL_DATA which is related to

    4. BucketIndex: 128 _HEAP_BUCKET, 128 _HEAP_LOCAL_SEGMENT_INFO, make the connection yourself :)

- _HEAP_SUBSEGMENT:

    1. LocalData PTR: Points to a _HEAP_LOCAL_DATA which is related to

    2. UserBlocks PTR: Points to a _HEAP_USERDATA_HEADER which is related to, which is prepended to a UserBlock

    3. _INTERLOCK_SEQ: Track of the current Offset and Depth.

    4. SizeIndex: The _HEAP_BUCKET SizeIndex for this subsegment (_HEAP_BUCKET[BucketIndex]->SizeIndex)

- [_HEAP_USERDATA_HEADER](https://terminus.rewolf.pl/terminus/structures/ntdll/_HEAP_USERDATA_HEADER_combined.html): UserBlock Chunk Headers - after SubSegment is located during LFH managed heap allocation, this structure indicates where the committed memory is located at.

- _INTERLOCK_SEQ:

    1. Depth: how many chunks left in UserBlock

    2. FreeEntryOffset: when added to address of _HEAP_USERDATA_HEADER, results in a pointer to the next location for allocation or freeing

- [_HEAP_BUCKET](http://terminus.rewolf.pl/terminus/structures/ntdll/_HEAP_BUCKET_combined.html)

    ```
    +0x000 BlockUnits : uint16_t
    +0x002 SizeIndex : uint16_t
    +0x003 UseAffinity : uint8_t
    +0x004 DebugFlags : uint8_t
    ```

- [_USER_MEMORY_CACHE_ENTRY](http://terminus.rewolf.pl/terminus/structures/ntdll/_USER_MEMORY_CACHE_ENTRY_combined.html)

    ```
    +0x000 UserBlocks : _SLIST_HEADER
    +0x008 AvailableBlocks : unsigned long
    ```

- _HEAP:

    1. BlocksIndex PTR: points to first _HEAP_LIST_LOOKUP

- _HEAP_LIST_LOOKUP:

    ```
    +0x000 ExtendedLookup : Ptr32 _HEAP_LIST_LOOKUP
    +0x004 ArraySize : Uint4B
    +0x008 ExtraItem : Uint4B
    +0x00c ItemCount : Uint4B
    +0x010 OutOfRangeItems : Uint4B
    +0x014 BaseIndex : Uint4B
    +0x018 ListHead : Ptr32 _LIST_ENTRY
    +0x01c ListsInUseUlong : Ptr32 Uint4B
    +0x020 ListHints : Ptr32 Ptr32 _LIST_ENTRY
    ```

Windows 7 Heap Allocation Algorithms:

0. Start with RtlAllocateHeap

1. Find index of ListHint that can service request

2. If cannot, return BlockIndex->ArraySize-1

3. If cannot find chunk that is big enough, call RtlpExtendHeap()

4. Once index (n) is acquired, we will try to use FreeList[n]

    1. We look at FreeList[n]->Blink to see if LFH is activated for that bucket 
    
    2. If activated use frontend RtlpLowFragHeapAllocFromContext()

    3. If not activated use backend and call RtlpAllocateHeap()

5. We then call RtlpAllocateHeap()

    1. Check if HEAP_NO_SERIALIZE set, if it is set, LFH will not be enabled for SUBSEQUENT request allocations

        - If it is set, activate LFH and perform heap mentenance. Even if the LFH is activated at this point and is able to service requests, backend allocator will continue to handle allocation

        - We will also apply a heuristic here to determine if the LFH should be USED for any later allocations

    2. Traverse through the FreeList and find chunk. If you can find a free chunk, then unlink the chunk safely and update the ListsInUseUlong and return 

    3. If cannot find chunk, go to _HEAP->FreeList and traverse from there. If still cannot find, run RtlpExtendHeap()
    
6. If not, we call RtlpLowFragHeapAllocFromContext()
    
    1. Called only if ListHint->blink set to 0x1. This will tell the heap manager if the blink contains a HeapBucket which means that the LFH is ready to serve requests. HeapBucket for that size must be activated/ready to indicate that the LFH is ready

    2. Call Hint SubSegment _LFH_HEAP=>LocalData=>SegmentInfo[n]=>Hint

    3. If fail, then call ActiveSubsegment SubSegment _LFH_HEAP=>LocalData=>SegmentInfo[n]=>ActiveSubsegment

    4. We will use the returned SubSegment's AggregateExchg data to obtain the depth, offset and sequence

    5. If Hint and Active SubSegments fails, then call retrieve new subsegment by allocating memory using the backend and dividing the large chunk of memory into userblocks for a heapbucket

        1. After we allocate memory, we need to couple it with a SubSegment either from _LFH_HEAP=>LocalData=>DeletedSubSegments
        
        2. If don't have then we will have to create one. To do so, we call RtlpLowFragHeapAllocateFromZone(), which either searches through _LFH_HEAP=>LocalData=>CrtZone=>ListEntry for available _LFH_BLOCK_ZONE structures to get addresses OR we will simply create new _LFH_BLOCK_ZONE structures via RtlAllocateHeap()
        
        3. We then initialize the SubSegment via RtlpSubSegmentInitialize which retrieves the necessary information to initialize a _HEAP_SUBSEGMENT structure

        4. Return the Active SubSegment 

Windows 7 Heap Free Algorithms:

1. Starts with RtlFreeHeap, find chunk to be freed, see if it is freeable and which manager is in charge

2. If it is allocated by backend, call RtlpFreeHeap

    1. Get Heap->BlockIndex

    2. Check if block array size if bigger than the request, if it is, we found our block

        - If not, check if there is a next block, if there isn't, set the index to the last value of the listhint array: ArraySize-1

        - Else, go next block and repeat prev step

    3. Once we find the appropriate block/_HEAP_LIST_LOOKUP structure, we search its listhint

        - If ListHint located but blink says that HeapBucket is NOT activated, run heuristics to see if LFH would be activated for that bucket

    4. Coalesce chunks using RtlpCoalesceFreeBlocks()

        - Need to see where to re-insert the free chunk, must be on ListHint/FreeLists

3.  Else, call RtlpLowFragHeapFree

    1. Get chunk header

    2. Get SubSegment belonging to chunk

    3. Check if SubSegment can handle a free chunk, if can, get the UserBlocks of SubSegment and the Depth, Offset, and Sequence relating to the Chunk and add chunk to SubSegment->Hint

    4. If cannot, call RtlpFreeUserBlock

### Windows 10 Heap Architecture:

References:

- https://www.blackhat.com/docs/us-16/materials/us-16-Yason-Windows-10-Segment-Heap-Internals-wp.pdf

- https://www.blackhat.com/docs/us-16/materials/us-16-Yason-Windows-10-Segment-Heap-Internals.pdf

- https://www.youtube.com/watch?v=hetZx78SQ_A&ab_channel=BlackHat 

- https://www.geeksforgeeks.org/introduction-to-red-black-tree/

There are 2 types of heap managaers: Segment Heap (new heap manager) and NT Heap (legacy heap manager).

NT Heap is the default heap for most applications while Segment Heap is the new heap that is used in Windows Apps for some system processes. As a result, if you want your application to use Segment Heap, you have to manually enable it.

In applications that are not opted-in by default to use the Segment Heap (i.e.: not a Windows app and not a system executable as discussed in 2.1), an additional 16 (0x10) bytes padding is added to the block. 

1. Segment Heap Architecture

    - Types of Allocation: Segment (small) vs Block (big)

    - How to tell if heap is managed by Segment or NT Heap? HeapBase!

    - If signature field is DDEEDDEE, then is managed by Segment Heap

    - All memory allocations done by NT Memory Manager

2. Backend Segment Heap Manager

    - Allocation size per page: 128kB to 508kB

    - Peforms segment allocation (VS or LFH)

        1. Variable Sized Allocation

            - Allocation size below 128kB

            - VS Blocks allocated from VS Segments which are from Backend segment block (see below)

            - Heap contains VSSubSegmentList which is a linked list of VS segments

            - Each vs subsegment contains a header and vs subsegment blocks

            - Each vs subsegment block contains a header which will differ based on whether its free or busy

            - Heap contains Free three which is RB tree to track free VS blocks

        2. Low Fragmentation Heap Allocation

            - Allocation size less than 16kB

            - Heap contains LfhContext.Buckets which points to LFH bucket-related structures in LFH Context Extension which then points to LFH subsegment

            - LFH Blocks allocated from LFH Segments which are from Backend segment block

            - Allocation size are distributed into buckets
            
            - Buckets are "activated" on the 17th allocation for that bucket size
            
            - Affinity Slots own the LFH subsegments that the LFH blocks are allocated from
            
            - Heap manager assigns processors to each affinity slot
            
            - If too much contention for affinity slots, new slots are created and another processor is assigned to it
            
            - Each LFH subsegment contains a header, blockbitmap and commitstate
            
            - Each LFH subsegment contains body which contains the LFH blocks
            
            - LFH allocation differs from VS and Backend (uses Best Fit Search through RB Trees)
            
            - LFH allocation is random, select bitmapbits from blockbitmap where busy bit is not set

    - 1 segment around 1MB
    
    - Heap contains SegmentListHead which is a linked list of segments

    - Each segment's header points to the next segment

    - Each segment's header contains Heap Page Range Descriptor corresponding to page in body

    - Each segment's body contains blocks which are group of pages

    - Heap contains Free Tree which is RB tree to track free backend blocks

3. Large Block Allocation Manager

    - Allocation size bigger than 508kB

    - Uses allocation bitmap similar to LFH

4. Security Mechanisms

    1.  Fast Fail
        
        - Checks Linked List structure (prevent arbitrary write)
        
        - Checks RB trees (prevent arbitrary write)

    2. Heap Address Randomization

        - Random Size of free memory created before HeapBase

    3. Guard Page

        - Prevent overflow outside subsegment 

    4. Function Point/VS Block Size/LFH Subsegment BlockOffsets Encoding

        - Prevent arbitrary writes

    5. LFH Allocation Randomization

        - Prevent UaF and buffer overflows

5. Case Study: CVE-2016-0117

### Other Interesting Windows Heap-related Material

- [Windows 8 Heap Exploitation](https://paper.bobylive.com/Meeting_Papers/BlackHat/Europe-2013/bh-eu-13-liu-advanced-heap-WP.pdf)

- [Windows 8 Heap Internals](https://www.youtube.com/watch?v=XxlzK0CLFN0&ab_channel=BlackHat)

- [Windows 8 Heap Internals Slides](https://media.blackhat.com/bh-us-12/Briefings/Valasek/BH_US_12_Valasek_Windows_8_Heap_Internals_Slides.pdf)

- [Windows 10 Segment Heap](https://speakerdeck.com/scwuaptx/windows-kernel-heap-segment-heap-in-windows-kernel-part-1?slide=28)

- [windowsland heap exploitation CTF](https://github.com/wmliang/windowsland)

- [Windows 11 Heap Management](https://www.pluralsight.com/courses/windows-11-internals-memory-management)

- [Anti-debugging Bypass for LFH](https://rce4fun.blogspot.com/2014/02/anti-debugging-trick-checking-for-low.html)

- [Heap Overflow Exploitation on Windows 10 Explained](https://www.rapid7.com/blog/post/2019/06/12/heap-overflow-exploitation-on-windows-10-explained/)

- [Windows XP - Windows 8 Heap Exploitation](https://srcincite.io/assets/D2T2-Steven-Seeley-Ghost-In-the-Allocator.pdf)