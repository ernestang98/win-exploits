void WasmIndirectFunctionTable::Set(uint32_t index, int sig_id,
                                    Address call_target, Object ref) {
  sig_ids()[index] = sig_id;
  targets()[index] = call_target;
  refs().set(index, ref);
}

targets is a raw pointer to raw pointers

if we can control targets + index, then we can control the where

targets can be manipulated using compressed r/w

call_target would be the what

https://chromium-review.googlesource.com/c/v8/v8/+/4687708

void WasmTableObject::Set(Isolate* isolate, Handle<WasmTableObject> table,
                          uint32_t index, Handle<Object> entry) {
  // ...
  switch (table->type().heap_representation()) {
    // ...
    default:
      DCHECK(!table->instance().IsUndefined());
      if (WasmInstanceObject::cast(table->instance())
              .module()
              ->has_signature(table->type().ref_index())) {
        SetFunctionTableEntry(isolate, table, entries, entry_index, entry); <- come here
        return;
      }
      entries->set(entry_index, *entry);
      return;
  }
}

- need to be a valid wasminstance object i guess

void WasmTableObject::SetFunctionTableEntry(Isolate* isolate,
                                            Handle<WasmTableObject> table,
                                            Handle<FixedArray> entries,
                                            int entry_index,
                                            Handle<Object> entry) {
  // ...
  Handle<Object> external = WasmInternalFunction::GetOrCreateExternal(
      Handle<WasmInternalFunction>::cast(entry));

  if (WasmExportedFunction::IsWasmExportedFunction(*external)) {
    auto exported_function = Handle<WasmExportedFunction>::cast(external);
    Handle<WasmInstanceObject> target_instance(exported_function->instance(),
                                               isolate);
    int func_index = exported_function->function_index();
    auto* wasm_function = &target_instance->module()->functions[func_index];
    UpdateDispatchTables(isolate, *table, entry_index, wasm_function,
                         *target_instance);
  }
  // ...
}

- need to be an exported wasm function i guess

void WasmTableObject::UpdateDispatchTables(Isolate* isolate,
                                           WasmTableObject table,
                                           int entry_index,
                                           const wasm::WasmFunction* func,
                                           WasmInstanceObject target_instance) {
  DisallowGarbageCollection no_gc;

  // We simply need to update the IFTs for each instance that imports
  // this table.
  FixedArray dispatch_tables = table.dispatch_tables();
  DCHECK_EQ(0, dispatch_tables.length() % kDispatchTableNumElements);

  // ...
  Address call_target = target_instance.GetCallTarget(func->func_index);

  int original_sig_id = func->sig_index;

  for (int i = 0, len = dispatch_tables.length(); i < len;
       i += kDispatchTableNumElements) {
    int table_index =
        Smi::cast(dispatch_tables.get(i + kDispatchTableIndexOffset)).value();
    WasmInstanceObject instance = WasmInstanceObject::cast(
        dispatch_tables.get(i + kDispatchTableInstanceOffset));
    int sig_id = target_instance.module()
                     ->isorecursive_canonical_type_ids[original_sig_id];
    WasmIndirectFunctionTable ift = WasmIndirectFunctionTable::cast(
        instance.indirect_function_tables().get(table_index));
    ift.Set(entry_index, sig_id, call_target, call_ref);
  }
}

- when you call table.set(INDEX, WASM_EXPORTED_FUNCTION) it will need to iterate through every entry in its dispatch table as every entry is equivalent to a WASM instance which imports the WASM table. Since the dispatch table will store the index of the wasm table relative to each wasm instance, it will use this index to return the IFT

- Each WASM Table will have an IFT

- call_target is the WHAT

Address WasmInstanceObject::GetCallTarget(uint32_t func_index) {
  wasm::NativeModule* native_module = module_object().native_module();
  if (func_index < native_module->num_imported_functions()) {
    return imported_function_targets().get(func_index);
  }
  return jump_table_start() +
         JumpTableOffset(native_module->module(), func_index);
}

- we see that of func_index is < native_module->num_imported_functions(), we will get from imported_function_targets instead

- this makes sense as imported_function_targets will be first in the jump_table followed by exported functions

- however, we can use comrpessed r/w to change the index of the exported functions, while also changing the pointers to the imported_function_targets

- since we can control targets pointer cuz its a raw pointer in the compressed v8 heap space, if we do something like table.set(0, FUNCTION), we will write FUNCTION address to the first qword (index 0) of targets which will be our address (e.g. 0x4141414141414141n). With this, we should have settled the where

- now is the tricky part: the what

    1. given that there are 4 imported function jstimes3 jstimes4 jstimes5 jstimes6, lets try to control jstimes4, which should be index 1 (in memory should be *2)

    2. change an exported function pwn from index 9 to index 1

    3. change jstimes4 to the WHAT

