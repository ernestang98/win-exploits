# CVE-2019-13768

https://chromium.googlesource.com/chromium/src/+/975798170a17a651cb399bdc030b9991cf2c7b3a/storage/browser/fileapi/file_writer_impl.cc#26

### Vulnerability: UaF

- Vulnerability located in the FileWriter APIs. FileWriter is exposed by the Browser which allows renderers to performed writes within sandboxed filesystems

- Look at the codes below:

  ```
  interface FileSystemManager {
    ...
    CreateWriter(url.mojom.Url file_path) => (mojo_base.mojom.FileError result, blink.mojom.FileWriter? writer);
    ...
  };
  void FileSystemManagerImpl::CreateWriter(const GURL& file_path, CreateWriterCallback callback) {
    ...
    mojo::MakeStrongBinding(
      std::make_unique<storage::FileWriterImpl>(url, context_->CreateFileSystemOperationRunner(),blob_storage_context_->context()->AsWeakPtr()),
      MakeRequest(&writer)
    );
    ...
  }
  interface FileWriter {
    ...
    Write(uint64 position, Blob blob) => (mojo_base.mojom.FileError result, uint64 bytes_written);
    ...
  }
  void FileWriterImpl::Write(uint64_t position, blink::mojom::BlobPtr blob, WriteCallback callback) {
    blob_context_->GetBlobDataFromBlobPtr(
      std::move(blob),
      base::BindOnce(&FileWriterImpl::DoWrite, base::Unretained(this), std::move(callback), position)
    );
  }
  void BlobStorageContext::GetBlobDataFromBlobPtr(
    blink::mojom::BlobPtr blob,
    base::OnceCallback<void(std::unique_ptr<BlobDataHandle>)> callback
  ) {
    DCHECK(blob);
    blink::mojom::Blob* raw_blob = blob.get();
    raw_blob->GetInternalUUID(
      mojo::WrapCallbackWithDefaultInvokeIfNotRun(
        base::BindOnce(
          [](
            blink::mojom::BlobPtr, base::WeakPtr<BlobStorageContext> context,
            base::OnceCallback<void(std::unique_ptr<BlobDataHandle>)> callback,
            const std::string& uuid
          ) {
            if (!context || uuid.empty()) {
              std::move(callback).Run(nullptr);
              return;
            }
            std::move(callback).Run(context->GetBlobDataFromUUID(uuid));
          },
          std::move(blob), 
          AsWeakPtr(), 
          std::move(callback)
        ),
        ""
      )
    );
  }
  interface Blob {
    ...
    GetInternalUUID() => (string uuid);
  };
  ```

  - CreateWriter creates a FileWriter object which is a StrongBinding object. 
  
    - mojo::StrongBinding objects are objects with their own interface implementation and can control the lifetime of the object as per [this sketchy chinese blog](https://www.cnblogs.com/huangguanyuan/p/10320950.html)

  - FileWriter::Write() will call GetBlobDataFromBlobPtr

  - GetBlobDataFromBlobPtr will call argument blob's GetInternalUUID() function which needs to return a UUID

    - The callback function which will execute at the end of GetInternalUUID is DoWrite

  - When the GetInternalUUID() returns, we will find the blob associated with the UUID and call the callback function with the blob as an argument

  - We can specify our own asynchronous GetInternalUUID() to trigger the free and fills

  - When the DoWrite (the callback function) is finally executed, it references the freed FileWriter object

### Writing the trigger exploit (just DoS this shit)



### Road to exploitation

```
chrome!storage::FileSystemOperationRunner::GetMetadata+0x33
storage/browser/fileapi/file_system_operation_runner.cc

OperationID FileSystemOperationRunner::GetMetadata(
    const FileSystemURL& url,
    int fields,
    GetMetadataCallback callback) {
  base::File::Error error = base::File::FILE_OK;
  std::unique_ptr<FileSystemOperation> operation = base::WrapUnique(
      file_system_context_->CreateFileSystemOperation(url, &error)); // here is hwere we crash
  FileSystemOperation* operation_raw = operation.get();
  OperationID id = BeginOperation(std::move(operation));
  base::AutoReset<bool> beginning(&is_beginning_operation_, true);
  if (!operation_raw) {
    DidGetMetadata(id, std::move(callback), error, base::File::Info());
    return id;
  }
  PrepareForRead(id, url);
  operation_raw->GetMetadata(
      url, fields,
      base::BindOnce(&FileSystemOperationRunner::DidGetMetadata, weak_ptr_, id,
                     std::move(callback)));
  return id;
}
...
chrome!storage::FileSystemContext::CreateFileSystemOperation+0x4c:
storage/browser/fileapi/file_system_context.cc

FileSystemOperation* FileSystemContext::CreateFileSystemOperation(
    const FileSystemURL& url, base::File::Error* error_code) {
  if (!url.is_valid()) {
    if (error_code)
      *error_code = base::File::FILE_ERROR_INVALID_URL;
    return nullptr;
  }

  FileSystemBackend* backend = GetFileSystemBackend(url.type());
  if (!backend) {
    if (error_code)
      *error_code = base::File::FILE_ERROR_FAILED;
    return nullptr;
  }

  base::File::Error fs_error = base::File::FILE_OK;
  FileSystemOperation* operation =
      backend->CreateFileSystemOperation(url, this, &fs_error);

  if (error_code)
    *error_code = fs_error;
  return operation;
}
```




Need to create a FileWriter via FileSystemManager.CreateWriter()



bug: FileWriter UaF
 
 
Mojo.bindInterface to interface with Mojo interfaces
 
new blink.mojom.*(); to create handles to Mojo resource
 
To create a FileWriter, we need to create FileSystemManager
 
 
CreateWriter returns a handle to FileWriter bound to a mojo::StrongBinding
 
Mojo can control the lifetime of the object
 
 
void FileWriterImpl::Write(uint64_t position,
                          blink::mojom::BlobPtr blob,
                          WriteCallback callback) {
 blob_context_->GetBlobDataFromBlobPtr(
     std::move(blob),
     base::BindOnce(&FileWriterImpl::DoWrite, base::Unretained(this),
                    std::move(callback), position));
}
 
write calls blob->GetBlobDataFromBlobPtr which essentially does blob->GetInternalUUID
 
 - we need to specify a GetInternalUUID function in our blob
 
 - GetInternalUUID will trigger the free, fill
 
        - GetInternalUUID returns (must return a blob uuid), it calls GetBlobDataFromUUID(uuid)





0:013> dq chrome_child!g_core
00007fff`9d838168  000001f6`51648f10 00007fff`9d838178
00007fff`9d838178  00000000`00000014 00000000`00000000
00007fff`9d838188  00000000`8000001f 00000000`00000000
00007fff`9d838198  00007fff`9cbc6a38 00000000`8000001e
00007fff`9d8381a8  00000000`00000000 00000000`00000000
00007fff`9d8381b8  00000000`00000000 00007fff`9d807f20
00007fff`9d8381c8  00000000`00000000 00000000`00000000
00007fff`9d8381d8  00000000`00000000 00000000`00000000
0:013> ? chrome_child!g_core-chrome_child
Evaluate expression: 87130472 = 00000000`05318168
0:013> dt chrome_child!mojo::core::Core 00007fff`9d838168
   +0x000 __VFN_table : 0x000001f6`51648f10 
   +0x008 node_controller_lock_ : base::Lock
   +0x010 node_controller_ : std::unique_ptr<mojo::core::NodeController,std::default_delete<mojo::core::NodeController> >
   +0x018 default_process_error_callback_ : base::RepeatingCallback<void (const std::basic_string<char,std::char_traits<char>,std::allocator<char> > &)>
   +0x020 handles_         : std::unique_ptr<mojo::core::HandleTable,std::default_delete<mojo::core::HandleTable> >
   +0x028 mapping_table_lock_ : base::Lock
   +0x030 mapping_table_   : std::unordered_map<void *,std::unique_ptr<mojo::core::PlatformSharedMemoryMapping,std::default_delete<mojo::core::PlatformSharedMemoryMapping> >,std::hash<void *>,std::equal_to<void *>,std::allocator<std::pair<void *const,std::unique_ptr<mojo::core::PlatformSharedMemoryMapping,std::default_delete<mojo::core::PlatformSharedMemoryMapping> > > > >


https://chromium.googlesource.com/chromium/src/+/refs/heads/main/mojo/core/core.h

https://chromium.googlesource.com/chromium/src/+/master/mojo/core/README.md

https://chromium.googlesource.com/chromium/src.git/+/refs/tags/91.0.4472.29/mojo/core/entrypoints.cc

https://chromium.googlesource.com/chromium/src/+/HEAD/mojo/core/dispatcher.cc

- mapBuffer

https://chromium.googlesource.com/chromium/src.git/+/72.0.3626.80/third_party/blink/web_tests/mojo/shared-buffer.html?autodive=0%2F%2F%2F

```
0:017> dq 286f75c02969 (286f75c0296a reads here)
0000286f`75c02969  c000007f`ff9d80f4 2100007b`f68a4ba1
0000286f`75c02979  f100003c`2b043025 f1000006`8ec3402c
0000286f`75c02989  a1000006`8ec3402c 59000031`8d736cb6
0000286f`75c02999  61000028`6f75c028 c1000031`8d736cbf
0000286f`75c029a9  81000059`01f57887 21000006`8ec34026
0000286f`75c029b9  f100003c`2b043025 f1000006`8ec3402c
0000286f`75c029c9  49000006`8ec3402c 59000031`8d736cb6
0000286f`75c029d9  51000028`6f75c028 c1000031`8d736cbf
0:017> dq 286f75c02969-1 (286f75c02969 reads here)
0000286f`75c02968  00007fff`9d80f428 00007bf6`8a4ba1c0
0000286f`75c02978  00003c2b`04302521 0000068e`c3402cf1
0000286f`75c02988  0000068e`c3402cf1 0000318d`736cb6a1
0000286f`75c02998  0000286f`75c02859 0000318d`736cbf61
0000286f`75c029a8  00005901`f57887c1 0000068e`c3402681
0000286f`75c029b8  00003c2b`04302521 0000068e`c3402cf1
0000286f`75c029c8  0000068e`c3402cf1 0000318d`736cb649
0000286f`75c029d8  0000286f`75c02859 0000318d`736cbf51
```

https://ruan777.github.io/2021/12/17/Chrome_issue1755%E5%88%86%E6%9E%90/

![](./settings.png)